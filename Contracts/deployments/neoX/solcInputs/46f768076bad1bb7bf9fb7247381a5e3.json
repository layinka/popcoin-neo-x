{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Nonces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/BondingCurve.sol": {
      "content": "// // SPDX-License-Identifier: MIT\r\n\r\n// pragma solidity ^0.8.17;\r\n\r\n// contract BondingCurve {\r\n//     uint256 public supply;\r\n//     uint256 public basePrice;\r\n//     uint256 public coefficient;\r\n//     uint256 public priceFloor;\r\n//     uint256 public priceCeiling;\r\n\r\n\r\n//     mapping(address => uint256) public balances;\r\n\r\n//     uint256 public targetMarketCap;\r\n//     bool public salesUnlocked;\r\n\r\n//     constructor() {\r\n//         supply = 0;\r\n//         basePrice = 1 ether; // adjustable base price\r\n//         coefficient = 2; // adjustable coefficient\r\n//         priceFloor = 0.5 ether; // adjustable price floor\r\n//         priceCeiling = 5 ether; // adjustable price ceiling\r\n\r\n//         targetMarketCap = 10000 ether; // set target market capitalization\r\n//         salesUnlocked = false;\r\n//     }\r\n\r\n    \r\n\r\n//     function getPrice() public view returns (uint256) {\r\n//         uint256 price = basePrice * (supply ^ coefficient);\r\n//         return min(max(price, priceFloor), priceCeiling);\r\n//     }\r\n\r\n//     function getMarketCap() public view returns (uint256) {\r\n//         return supply * getPrice();\r\n//     }\r\n\r\n\r\n//     function buy(address user, uint256 amount) public {\r\n//         // update user balance and total supply\r\n//         balances[user] += amount;\r\n//         supply += amount;\r\n//         // update price and market capitalization\r\n//         uint256 price = getPrice();\r\n//         uint256 marketCap = getMarketCap();\r\n//         // check if target market capitalization reached\r\n//         if (marketCap >= targetMarketCap) {\r\n//             salesUnlocked = true;\r\n//         }\r\n//     }\r\n\r\n//     function sell(address user, uint256 amount) public {\r\n//         // check if sales are unlocked\r\n//         require(salesUnlocked, \"Sales are locked\");\r\n//         // update user balance and total supply\r\n//         balances[user] -= amount;\r\n//         supply -= amount;\r\n//     }\r\n\r\n//     function mint(address to, uint256 amount) public {\r\n//         // check if target market capitalization reached\r\n//         require(!salesUnlocked, \"Target market capitalization reached\");\r\n//         // mint new tokens\r\n//         supply += amount;\r\n//         balances[to] += amount;\r\n//     }\r\n\r\n//     function getHolders() public view returns (address[] memory) {\r\n//         address[] memory holders = new address[](0);\r\n//         for (uint i = 0; i< balances.length; i++) {\r\n//             address user = balances[i];\r\n//             if (balances[user] > 0) {\r\n//                 holders.push(user);\r\n//             }\r\n//         }\r\n//         return holders;\r\n//     }\r\n\r\n// }\r\n\r\n\r\n// function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//     return a < b ? a : b;\r\n// }\r\n\r\n// function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//     return a > b ? a : b;\r\n// }\r\n\r\n\r\n"
    },
    "contracts/CappedGasPrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.26;\r\n\r\n\r\n\r\nerror ExceededMaxGasPrice(uint maxGasPrice);\r\n\r\ncontract CappedGasPrice  {  \r\n    uint256 public maxGasPrice = 1 * 10**18; // Adjustable value\r\n    address owner;\r\n\r\n    modifier validGasPrice() {    \r\n        require(tx.gasprice <= maxGasPrice, ExceededMaxGasPrice(maxGasPrice));    \r\n        _;  \r\n    }\r\n\r\n    modifier onlyOwner() {    \r\n        require(msg.sender==owner, ExceededMaxGasPrice(maxGasPrice));    \r\n        _;  \r\n    }\r\n\r\n    constructor(uint256 _maxGasPrice, address _owner)  {\r\n        maxGasPrice=_maxGasPrice;\r\n        owner=_owner;\r\n    }\r\n    \r\n\r\n    function setMaxGasPrice(uint256 _maxGasPrice) public onlyOwner {    \r\n        maxGasPrice=_maxGasPrice; \r\n        \r\n    }\r\n\r\n    function changeOwner(address _owner) public onlyOwner {    \r\n        owner=_owner;\r\n        \r\n    }\r\n        \r\n}"
    },
    "contracts/ERC20/ERC20Base.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./ERC20Internal.sol\";\nimport \"../Libraries/Constants.sol\";\n\ninterface ITransferReceiver {\n\tfunction onTokenTransfer(\n\t\taddress,\n\t\tuint256,\n\t\tbytes calldata\n\t) external returns (bool);\n}\n\ninterface IPaidForReceiver {\n\tfunction onTokenPaidFor(\n\t\taddress payer,\n\t\taddress forAddress,\n\t\tuint256 amount,\n\t\tbytes calldata data\n\t) external returns (bool);\n}\n\ninterface IApprovalReceiver {\n\tfunction onTokenApproval(\n\t\taddress,\n\t\tuint256,\n\t\tbytes calldata\n\t) external returns (bool);\n}\n\nabstract contract ERC20Base is IERC20, ERC20Internal {\n\tusing Address for address;\n\n\tuint256 internal _totalSupply;\n\tmapping(address => uint256) internal _balances;\n\tmapping(address => mapping(address => uint256)) internal _allowances;\n\n\tfunction burn(uint256 amount) external virtual {\n\t\taddress sender = msg.sender;\n\t\t_burnFrom(sender, amount);\n\t}\n\n\tfunction _internal_totalSupply() internal view override returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\n\tfunction totalSupply() public view override returns (uint256) {\n\t\treturn _internal_totalSupply();\n\t}\n\n\tfunction balanceOf(address owner) external view override returns (uint256) {\n\t\treturn _balances[owner];\n\t}\n\n\tfunction allowance(address owner, address spender) external view override returns (uint256) {\n\t\tif (owner == address(this)) {\n\t\t\t// see transferFrom: address(this) allows anyone\n\t\t\treturn Constants.UINT256_MAX;\n\t\t}\n\t\treturn _allowances[owner][spender];\n\t}\n\n\tfunction decimals() external pure virtual returns (uint8) {\n\t\treturn uint8(18);\n\t}\n\n\tfunction transfer(address to, uint256 amount) external override returns (bool) {\n\t\t_transfer(msg.sender, to, amount);\n\t\treturn true;\n\t}\n\n\tfunction transferAlongWithETH(address payable to, uint256 amount) external payable returns (bool) {\n\t\t_transfer(msg.sender, to, amount);\n\t\tto.transfer(msg.value);\n\t\treturn true;\n\t}\n\n\tfunction distributeAlongWithETH(address payable[] memory tos, uint256 totalAmount) external payable returns (bool) {\n\t\tuint256 val = msg.value / tos.length;\n\t\trequire(msg.value == val * tos.length, \"INVALID_MSG_VALUE\");\n\t\tuint256 amount = totalAmount / tos.length;\n\t\trequire(totalAmount == amount * tos.length, \"INVALID_TOTAL_AMOUNT\");\n\t\tfor (uint256 i = 0; i < tos.length; i++) {\n\t\t\t_transfer(msg.sender, tos[i], amount);\n\t\t\ttos[i].transfer(val);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction transferAndCall(\n\t\taddress to,\n\t\tuint256 amount,\n\t\tbytes calldata data\n\t) external returns (bool) {\n\t\t_transfer(msg.sender, to, amount);\n\t\treturn ITransferReceiver(to).onTokenTransfer(msg.sender, amount, data);\n\t}\n\n\tfunction transferFromAndCall(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount,\n\t\tbytes calldata data\n\t) external returns (bool) {\n\t\t_transferFrom(from, to, amount);\n\t\treturn ITransferReceiver(to).onTokenTransfer(from, amount, data);\n\t}\n\n\tfunction payForAndCall(\n\t\taddress forAddress,\n\t\taddress to,\n\t\tuint256 amount,\n\t\tbytes calldata data\n\t) external returns (bool) {\n\t\t_transfer(msg.sender, to, amount);\n\t\treturn IPaidForReceiver(to).onTokenPaidFor(msg.sender, forAddress, amount, data);\n\t}\n\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) external override returns (bool) {\n\t\t_transferFrom(from, to, amount);\n\t\treturn true;\n\t}\n\n\tfunction approve(address spender, uint256 amount) external override returns (bool) {\n\t\t_approveFor(msg.sender, spender, amount);\n\t\treturn true;\n\t}\n\n\tfunction approveAndCall(\n\t\taddress spender,\n\t\tuint256 amount,\n\t\tbytes calldata data\n\t) external returns (bool) {\n\t\t_approveFor(msg.sender, spender, amount);\n\t\treturn IApprovalReceiver(spender).onTokenApproval(msg.sender, amount, data);\n\t}\n\n\tfunction _approveFor(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 amount\n\t) internal override {\n\t\trequire(owner != address(0) && spender != address(0), \"INVALID_ZERO_ADDRESS\");\n\t\t_allowances[owner][spender] = amount;\n\t\temit Approval(owner, spender, amount);\n\t}\n\n\tfunction _transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal {\n\t\t// anybody can transfer from this\n\t\t// this allow mintAndApprovedCall without gas overhead\n\t\tif (msg.sender != from && from != address(this)) {\n\t\t\tuint256 currentAllowance = _allowances[from][msg.sender];\n\t\t\tif (currentAllowance != Constants.UINT256_MAX) {\n\t\t\t\t// save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n\t\t\t\trequire(currentAllowance >= amount, \"NOT_AUTHOIZED_ALLOWANCE\");\n\t\t\t\t_allowances[from][msg.sender] = currentAllowance - amount;\n\t\t\t}\n\t\t}\n\t\t_transfer(from, to, amount);\n\t}\n\n\tfunction _transfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal {\n\t\trequire(to != address(0), \"INVALID_ZERO_ADDRESS\");\n\t\trequire(to != address(this), \"INVALID_THIS_ADDRESS\");\n\t\tuint256 currentBalance = _balances[from];\n\t\trequire(currentBalance >= amount, \"NOT_ENOUGH_TOKENS\");\n\t\t_balances[from] = currentBalance - amount;\n\t\t_balances[to] += amount;\n\t\temit Transfer(from, to, amount);\n\t}\n\n\tfunction _transferAllIfAny(address from, address to) internal {\n\t\tuint256 balanceLeft = _balances[from];\n\t\tif (balanceLeft > 0) {\n\t\t\t_balances[from] = 0;\n\t\t\t_balances[to] += balanceLeft;\n\t\t\temit Transfer(from, to, balanceLeft);\n\t\t}\n\t}\n\n\tfunction _mint(address to, uint256 amount) internal override {\n\t\t_totalSupply += amount;\n\t\t_balances[to] += amount;\n\t\temit Transfer(address(0), to, amount);\n\t}\n\n\tfunction _burnFrom(address from, uint256 amount) internal override {\n\t\tuint256 currentBalance = _balances[from];\n\t\trequire(currentBalance >= amount, \"NOT_ENOUGH_TOKENS\");\n\t\t_balances[from] = currentBalance - amount;\n\t\t_totalSupply -= amount;\n\t\temit Transfer(from, address(0), amount);\n\t}\n}\n"
    },
    "contracts/ERC20/ERC20Internal.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity ^0.8.17;\n\nabstract contract ERC20Internal {\n\tfunction _approveFor(\n\t\taddress owner,\n\t\taddress target,\n\t\tuint256 amount\n\t) internal virtual;\n\n\tfunction name() public virtual returns (string memory);\n\n\tfunction _mint(address to, uint256 amount) internal virtual;\n\n\tfunction _burnFrom(address from, uint256 amount) internal virtual;\n\n\tfunction _internal_totalSupply() internal view virtual returns (uint256);\n}\n"
    },
    "contracts/ERC20/SimpleERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./ERC20Base.sol\";\nimport \"./WithPermitAndFixedDomain.sol\";\n\ncontract SimpleERC20 is ERC20Base, WithPermitAndFixedDomain {\n\tconstructor(address to, uint256 amount) WithPermitAndFixedDomain(\"1\") {\n\t\t_mint(to, amount);\n\t}\n\n\tstring public constant symbol = \"SIMPLE\";\n\n\tfunction name() public pure override returns (string memory) {\n\t\treturn \"Simple ERC20\";\n\t}\n}\n"
    },
    "contracts/ERC20/WithPermit.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity ^0.8.17;\n\nimport \"./ERC20Internal.sol\";\nimport \"../Interfaces/IERC2612Standalone.sol\";\n\nabstract contract WithPermit is ERC20Internal, IERC2612Standalone {\n\tbytes32 internal constant PERMIT_TYPEHASH =\n\t\tkeccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\tmapping(address => uint256) internal _nonces;\n\n\tfunction DOMAIN_SEPARATOR() public view virtual override returns (bytes32);\n\n\tfunction nonces(address owner) external view override returns (uint256) {\n\t\treturn _nonces[owner];\n\t}\n\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external override {\n\t\trequire(owner != address(0), \"INVALID_ZERO_ADDRESS\");\n\n\t\tuint256 currentNonce = _nonces[owner];\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"\\x19\\x01\",\n\t\t\t\tDOMAIN_SEPARATOR(),\n\t\t\t\tkeccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentNonce, deadline))\n\t\t\t)\n\t\t);\n\t\trequire(owner == ecrecover(digest, v, r, s), \"INVALID_SIGNATURE\");\n\t\trequire(deadline == 0 || block.timestamp <= deadline, \"TOO_LATE\");\n\n\t\t_nonces[owner] = currentNonce + 1;\n\t\t_approveFor(owner, spender, value);\n\t}\n}\n"
    },
    "contracts/ERC20/WithPermitAndFixedDomain.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity ^0.8.17;\n\nimport \"./ERC20Internal.sol\";\nimport \"../Interfaces/IERC2612Standalone.sol\";\n\nabstract contract WithPermitAndFixedDomain is ERC20Internal, IERC2612Standalone {\n\tbytes32 internal constant PERMIT_TYPEHASH =\n\t\tkeccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\t// solhint-disable-next-line var-name-mixedcase\n\tbytes32 public immutable override DOMAIN_SEPARATOR;\n\n\tmapping(address => uint256) internal _nonces;\n\n\tconstructor(string memory version) {\n\t\tif (bytes(version).length == 0) {\n\t\t\tversion = \"1\";\n\t\t}\n\t\tDOMAIN_SEPARATOR = keccak256(\n\t\t\tabi.encode(\n\t\t\t\tkeccak256(\"EIP712Domain(string name,string version,address verifyingContract)\"),\n\t\t\t\tkeccak256(bytes(name())),\n\t\t\t\tkeccak256(bytes(version)),\n\t\t\t\taddress(this)\n\t\t\t)\n\t\t);\n\t}\n\n\tfunction nonces(address owner) external view override returns (uint256) {\n\t\treturn _nonces[owner];\n\t}\n\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external override {\n\t\trequire(owner != address(0), \"INVALID_ZERO_ADDRESS\");\n\n\t\tuint256 currentNonce = _nonces[owner];\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"\\x19\\x01\",\n\t\t\t\tDOMAIN_SEPARATOR,\n\t\t\t\tkeccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentNonce, deadline))\n\t\t\t)\n\t\t);\n\t\trequire(owner == ecrecover(digest, v, r, s), \"INVALID_SIGNATURE\");\n\t\trequire(deadline == 0 || block.timestamp <= deadline, \"TOO_LATE\");\n\n\t\t_nonces[owner] = currentNonce + 1;\n\t\t_approveFor(owner, spender, value);\n\t}\n}\n"
    },
    "contracts/Faucet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\r\npragma solidity ^0.8.23;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ncontract Faucet {\r\n\tusing SafeERC20 for IERC20;\r\n\r\n\tevent Withdrawn(address withdrawer, uint amount);\r\n\tuint max = 100 ether;\r\n\tmapping(address => uint256) withdrawals;\r\n\r\n\tconstructor() {}\r\n\r\n\tfunction withdraw(IERC20 currency, uint amount) public {\r\n\t\taddress sender = msg.sender;\r\n\t\trequire(withdrawals[sender] + amount <= max, \"Max Limit will be exceeded\");\r\n\r\n\t\twithdrawals[sender] += amount;\r\n\t\tcurrency.safeTransfer(\r\n\t\t\t// address(this),\r\n\t\t\tsender,\r\n\t\t\tamount\r\n\t\t);\r\n\r\n\t\temit Withdrawn(sender, amount);\r\n\t}\r\n}\r\n"
    },
    "contracts/FunToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\r\npragma solidity ^0.8.23;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./IDexRouter.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ninterface IPopCoinFactory {\r\n    function notifyTrade(address trader, address tokenAddress, uint tradeType, uint tradePrice, uint tradeAmount) external;\r\n}\r\n\r\n\r\n // Custom errors\r\nerror InsufficientETH(uint256 sent, uint256 required);\r\nerror InsufficientTokens(uint256 available, uint256 required);\r\nerror InsufficientContractETH(uint256 available, uint256 required);\r\nerror TransferFailed();\r\nerror BalanceExceeded(uint256 available, uint256 required);\r\nerror ExceededMaxBuy(uint maxBuy);\r\nerror LiquidityAlreadySent();\r\nerror SlippageExceeded(uint256 current, uint256 max);\r\nerror ExceedsMarketCap();\r\n\r\ncontract FunToken is ERC20, ReentrancyGuard, Ownable {\r\n    address public constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\r\n\r\n\tIDexRouter public immutable v2Router;\r\n\tuint8 decimalPlaces=18;\r\n    uint256 public targetMarketCap;                // Target market cap in wei\r\n    uint256 public transactionFeePercent;                     // Fee percentage for transactions (in basis points)\r\n    address public feeAddress;                     // Address to receive transaction fees\r\n    uint256 public liquidityDeploymentPercent;     // Percentage of liquidity to deploy to DEX\r\n    address public routerAddress;                     // Address of the DEX to deploy liquidity to\r\n    uint256 public immutable fixedSupply=1_000_000_000 ether;          // Fixed supply of the token\r\n    uint256 public immutable initialFixedSupply=800_000_000 ether;          // Fixed supply of the token\r\n\r\n    uint256 public netBoughtTokens;                // Tracks the net amount of tokens bought\r\n    uint256 public ethPaid; \r\n\tuint256 public maxBuy = 5 ether;\r\n    uint256 deployLiquidityFee=5 ether; \r\n\r\n    // address popCoinFactory;\r\n    IPopCoinFactory popCoinFactory;\r\n\r\n    bool public liquiditySent = false;\r\n\r\n    uint256 constant private MAX_INT = 2**256 - 1;\r\n\r\n     // Constants derived from the fitting y=f- t/(k+x) where x=supply in Sale Coin\r\n    uint256 private constant F = 1071000120;\r\n    uint256 private constant T = 11229068400;\r\n    uint256 private constant K = 10.48465702 ether;  // 10.48465702\r\n\r\n    // event BoughtToken(address indexed buyer, uint amountPaid);\r\n    // event SoldToken(address indexed buyer, uint amountPaid);\r\n    event LiquidityDeployed();\r\n\r\n    \r\n    uint256 private constant PRECISION = 10**18; // To maintain precision for Ether and token calculations\r\n\r\n    uint256 public liquidityAmount;\r\n    //todo\r\n    //resrtrict owner withdrawal until coins have been moved to DEX\r\n\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,        \r\n        uint256 _targetMarketCap,\r\n        uint256 _transactionFeePercent,\r\n        address _feeAddress,\r\n        uint256 _liquidityDeploymentPercent,\r\n        address _routerAddress,\r\n\t\taddress _creator,\r\n\t\tuint _initialBuyInEth,\r\n        uint256 _deployLiquidityFee,\r\n        uint256 _liquidityAmount\r\n    ) ERC20(name, symbol) Ownable(_creator) {\r\n        popCoinFactory=IPopCoinFactory( msg.sender);\r\n        targetMarketCap = _targetMarketCap;\r\n        transactionFeePercent = _transactionFeePercent;\r\n        feeAddress = _feeAddress;\r\n        liquidityDeploymentPercent = _liquidityDeploymentPercent;\r\n        routerAddress = _routerAddress;\r\n\t\tv2Router = IDexRouter(_routerAddress);\r\n        deployLiquidityFee=_deployLiquidityFee;\r\n        liquidityAmount=_liquidityAmount;\r\n        // console.log(\"INITIAL ethPaid %d \",ethPaid);\r\n        // Initially mint the initial fixed supply to the contract itself\r\n\t\tuint initialTokensForCreator = calculateNumberOfTokensToBuy(_initialBuyInEth);\r\n        _mint(address(this), initialFixedSupply - initialTokensForCreator);\r\n\t\t_mint(_creator, initialTokensForCreator);\r\n        ethPaid+=_initialBuyInEth;\r\n        netBoughtTokens+=initialTokensForCreator;\r\n        // console.log(\"INITIAL2 ethPaid %d \",ethPaid);\r\n\r\n        // console.log(\"creator %s , _initialBuyInEth %d, initialTokensForCreator %d \",_creator, _initialBuyInEth, initialTokensForCreator);\r\n    }\r\n\r\n\tfunction decimals() public view virtual override returns (uint8) {\r\n\t\treturn decimalPlaces;\r\n\t}\r\n\r\n    // returns actual no  not scaled t 18 decimals\r\n    function tokensIssued(uint supplyInEth) public pure returns (uint) {\r\n        \r\n        // Scale up supplyInEth by the precision factor to maintain accuracy during division\r\n        uint256 scaledSupply = (supplyInEth * PRECISION) / 10**18; // Now, scaledSupply has the same precision as 1 ETH\r\n\r\n        // Perform the calculation with scaledSupply\r\n        // Here, we add the precision factor to 30 to keep the units consistent during the calculation\r\n        uint256 result = F - T * PRECISION / (K  + scaledSupply);\r\n        // console.log(\"tokensIssued::  supplyInEth %d, tokens %d \",supplyInEth, result);\r\n        return result;\r\n    }\r\n\r\n\r\n    function price(uint supplyInEth) public pure returns (uint) {\r\n        uint tokensIssued = tokensIssued(supplyInEth);\r\n\r\n        return supplyInEth/tokensIssued;\r\n    }\r\n\r\n    // Function to calculate the amount of tokens T for given Ether (ETH) paid\r\n    function calculateNumberOfTokensToBuy( uint256 amount) public view returns (uint256) {\r\n        return calculateNumberOfTokensToBuy(ethPaid,amount);\r\n    }\r\n    // Function to calculate the amount of tokens T for given Ether (ETH) paid\r\n    function calculateNumberOfTokensToBuy(uint256 totalEthInContract, uint256 amount) public view returns (uint256) {\r\n        uint256 initialTokens = tokensIssued(totalEthInContract);\r\n        uint256 newEthTotal = totalEthInContract + amount;\r\n        uint256 finalTokens = tokensIssued(newEthTotal);\r\n\r\n        uint256 tokensToIssue = finalTokens - initialTokens;\r\n        // console.log('newEthTotal %d ',newEthTotal);\r\n        // console.log('totalEthInContract %d , initialTokens %d , finalTokens %d ',totalEthInContract, initialTokens, finalTokens);\r\n\r\n        return tokensToIssue * PRECISION;\r\n    }\r\n\r\n    // Function to calculate the amount of Ether (ETH) needed to buy a specific number of tokens (T)\r\n    function calculateNumberOfTokensToBuyWithTokens( uint256 amount) public view returns (uint256) {\r\n        return calculateNumberOfTokensToBuyWithTokens(ethPaid,amount);\r\n    }\r\n\r\n    // Function to calculate the amount of Ether (ETH) needed to buy a specific number of tokens (T)\r\n    function calculateNumberOfTokensToBuyWithTokens(uint256 totalEthInContract,  uint256 tokensToBuy) public view returns (uint256) {\r\n        \r\n        uint256 initialTokens = tokensIssued(totalEthInContract);\r\n        // console.log(\" initialTokens %d, tokensToBuy %d\", initialTokens, tokensToBuy);\r\n        uint256 targetTokens = (initialTokens*PRECISION + tokensToBuy)/PRECISION;\r\n        \r\n        // Invert the formula to solve for x (Ether) when we know y (tokens)\r\n        uint256 targetEth = T * PRECISION / (F - targetTokens) - K;\r\n        // console.log(\"targetTokens %d, targetEth %d, tokensToBuy %d\",targetTokens, targetEth, tokensToBuy);\r\n\r\n        uint256 ethNeeded = targetEth  - totalEthInContract;\r\n        // console.log(\"totalEthInContract %d, realBalance %d, ethNeeded %d\",totalEthInContract, address(this).balance, ethNeeded);\r\n        return ethNeeded;\r\n    }\r\n\r\n    \r\n\r\n\r\n    // Function to calculate the amount of Ether (ETH) returned for selling a certain amount of tokens (T)\r\n    function calculateNumberOfETHSoldForToken( uint256 tokensToSell) public view returns (uint256) {\r\n        // console.log(\" ethPaid %d, tokensToSell %d\",ethPaid, tokensToSell);\r\n        return calculateNumberOfETHSoldForToken(ethPaid,tokensToSell);\r\n    }\r\n\r\n    function calculateNumberOfETHSoldForToken(uint256 totalEthInContract,  uint256 tokensToSell) public view returns (uint256) {\r\n        // console.log(\"SELLING:: tokensToSell %d \", tokensToSell );\r\n        uint256 initialTokens = tokensIssued(totalEthInContract);\r\n        // console.log(\"SELLING:: initialTokens %d , totalEthInContract %d \", initialTokens, totalEthInContract );\r\n        uint256 targetTokens = initialTokens - tokensToSell/PRECISION;\r\n\r\n        console.log(\"SELLING:: initialTokens %d, tokensToSell %d , targetTokens %d \", initialTokens,tokensToSell, targetTokens );\r\n\r\n        // // Invert the formula to solve for x (Ether) when we know y (tokens)\r\n        // // y = F - T / (K + x)\r\n        // // => T / (K + x) = F - y\r\n        // // => x = T / (F - y) - K\r\n        // // console.log(\"SELLING:: T  %d \", (T ) );\r\n        console.log(\"SELLING:: K  %d, K/PRECISION %d \", K, (K/PRECISION ) );\r\n        console.log(\"SELLING:: (F - targetTokens) %d \", (F - targetTokens) );\r\n        console.log(\"SELLING:: (T * PRECISION  / (F - targetTokens)) %d \", (T * PRECISION  / (F - targetTokens)) );\r\n        uint256 targetEth = (T * PRECISION  / (F - targetTokens)) - (K);\r\n        console.log(\"SELLING:: totalEthInContract %d, targetEth %d \",totalEthInContract,  targetEth );\r\n        uint256 ethToReturn = totalEthInContract - targetEth ;\r\n        console.log(\"SELLING:: ethToReturn %d \", ethToReturn );\r\n\r\n        return ethToReturn;\r\n    }\r\n\r\n    // function calculateNumberOfETHSoldForTokenOld(uint256 totalEthInContract,  uint256 tokensToSell) public view returns (uint256) {\r\n    //     // console.log(\"SELLING:: tokensToSell %d \", tokensToSell );\r\n    //     uint256 initialTokens = tokensIssued(totalEthInContract);\r\n    //     // console.log(\"SELLING:: initialTokens %d , totalEthInContract %d \", initialTokens, totalEthInContract );\r\n    //     uint256 targetTokens = initialTokens - tokensToSell/PRECISION;\r\n\r\n    //     // console.log(\"SELLING:: initialTokens %d, tokensToSell %d , targetTokens %d \", initialTokens,tokensToSell, targetTokens );\r\n\r\n    //     // Invert the formula to solve for x (Ether) when we know y (tokens)\r\n    //     // y = F - T / (K + x)\r\n    //     // => T / (K + x) = F - y\r\n    //     // => x = T / (F - y) - K\r\n    //     // console.log(\"SELLING:: (T * PRECISION) %d \", (T * PRECISION) );\r\n    //     // console.log(\"SELLING:: (F - targetTokens) %d \", (F - targetTokens) );\r\n    //     uint256 targetEth = (T * PRECISION / (F - targetTokens)) - (K);\r\n    //     console.log(\"SELLING:: targetEth %d \", targetEth );\r\n    //     uint256 ethToReturn = totalEthInContract - targetEth / PRECISION;\r\n    //     console.log(\"SELLING:: ethToReturn %d \", ethToReturn );\r\n\r\n    //     return ethToReturn;\r\n    // }\r\n\r\n    \r\n\r\n\r\n\r\n\r\n    // Helper function to calculate exponential in a fixed-point format\r\n    function exp(uint256 x) internal pure returns (uint256) {\r\n        // x is expected to be in the fixed-point format with 18 decimal places\r\n        // We use an approximation for e^x: exp(x) = sum(x^n / n!)\r\n        // For simplicity and avoiding excessive gas cost, we'll approximate up to 6 terms\r\n\r\n        uint256 term = x;\r\n        uint256 result = 1 ether; // e^0 = 1\r\n        result += term;\r\n\r\n        term = (term * x) / 1 ether; // x^2 / 2!\r\n        result += term / 2;\r\n\r\n        term = (term * x) / 1 ether; // x^3 / 3!\r\n        result += term / 6;\r\n\r\n        term = (term * x) / 1 ether; // x^4 / 4!\r\n        result += term / 24;\r\n\r\n        term = (term * x) / 1 ether; // x^5 / 5!\r\n        result += term / 120;\r\n\r\n        term = (term * x) / 1 ether; // x^6 / 6!\r\n        result += term / 720;\r\n\r\n        return result;\r\n    }\r\n\r\n\r\n    // Function to buy tokens by specifying the ETH amount\r\n    function buyWithETH(uint256 amount, uint256 maxSlippagePercent) external payable nonReentrant {\r\n        \r\n\r\n        if (liquiditySent) revert LiquidityAlreadySent();\r\n        if (amount > maxBuy) revert ExceededMaxBuy(maxBuy);\r\n        console.log('amount %d,ethPaid %d,targetMarketCap %d', amount ,ethPaid,targetMarketCap);\r\n        console.log('amount + ethPaid %d,targetMarketCap %d', amount + ethPaid,targetMarketCap);\r\n        if(amount + ethPaid>targetMarketCap) revert ExceedsMarketCap();\r\n        \r\n        uint256 fee = (amount * transactionFeePercent) / 10000;\r\n        uint256 netAmount = amount + fee;// in ETH\r\n        \r\n        if (netAmount > msg.value) revert InsufficientETH(msg.value, netAmount);\r\n\r\n        // Calculate the expected price per token (in ETH)\r\n        uint256 totalEthInContractBefore = ethPaid;// address(this).balance - msg.value;\r\n        // uint256 initialTokens = tokensIssued(totalEthInContractBefore);\r\n        uint256 expectedPricePerToken = amount / calculateNumberOfTokensToBuy(amount);\r\n\r\n        \r\n        // Calculate the number of tokens expected for the given ETH amount\r\n        uint256 tokensToBuy = calculateNumberOfTokensToBuy(ethPaid , amount);\r\n        ethPaid+= amount;\r\n        console.log('BUYWITHETH:: tokensToBuy %d, expectedPricePerToken: %d', tokensToBuy, expectedPricePerToken);\r\n        // Check the token balance available for sale\r\n        if (tokensToBuy > balanceOf(address(this))) revert InsufficientTokens(balanceOf(address(this)), tokensToBuy);\r\n\r\n        \r\n\r\n        // console.log('initialTokens %d, expectedPricePerToken: %d', initialTokens, expectedPricePerToken);\r\n        uint currentTokenBalance = balanceOf(address(this));\r\n        console.log('currentTokenBalance %d , tokensToBuy %d', currentTokenBalance, tokensToBuy);\r\n        // Perform the token transfer and handle fees\r\n        payable(feeAddress).transfer(fee);\r\n        _transfer(address(this), msg.sender, tokensToBuy);\r\n        netBoughtTokens += tokensToBuy; // Increase net bought tokens\r\n\r\n        currentTokenBalance = balanceOf(address(this));\r\n        console.log('currentTokenBalance after %d , tokensToBuy %d', currentTokenBalance, tokensToBuy);\r\n\r\n        // Calculate the actual price per token after the transaction\r\n        uint256 totalEthInContractAfter = ethPaid;// address(this).balance;\r\n        // uint256 finalTokens = tokensIssued(totalEthInContractAfter);\r\n        uint256 effectivePricePerToken = (totalEthInContractAfter - totalEthInContractBefore) / tokensToBuy;\r\n\r\n        // console.log('finalTokens %d, effectivePricePerToken: %d', finalTokens, effectivePricePerToken);\r\n        // Calculate the allowed slippage\r\n        uint256 maxAllowedSlippage = (expectedPricePerToken * (10000  + maxSlippagePercent)) / 10000 ;\r\n        // Ensure the effective price does not exceed the maximum allowed price with slippage\r\n        // require(effectivePricePerToken <= maxAllowedSlippage, \"Slippage too high\");\r\n        if (effectivePricePerToken > maxAllowedSlippage) {\r\n            revert SlippageExceeded(effectivePricePerToken, maxAllowedSlippage);\r\n        }\r\n\r\n        // emit BoughtToken(msg.sender, amount);\r\n        popCoinFactory.notifyTrade(msg.sender, address(this),0, tokensToBuy, amount );\r\n        // console.log('amount/(finalTokens-initialTokens) %d, effectivePricePerToken: %d', amount/(finalTokens-initialTokens), effectivePricePerToken);\r\n        // console.log('maxAllowedSlippage %d, expectedPricePerToken: %d', maxAllowedSlippage, effectivePricePerToken);\r\n        // console.log('Real ETH BAl %d, targetMarketCap: %d', address(this).balance, targetMarketCap);\r\n\r\n        // Deploy liquidity if the target market cap is reached\r\n\r\n        console.log('address(this).balance %d , netBoughtTokens %d, ethPaid %d', address(this).balance, netBoughtTokens, ethPaid);\r\n        if (address(this).balance >= targetMarketCap) {\r\n            _sendLiquidity();\r\n        }\r\n    }\r\n\r\n    \r\n    // Function to buy tokens by specifying the amount of tokens to buy, send cost of buying  plus tx fee\r\n    function buy(uint256 amount, uint256 maxSlippagePercent) external payable nonReentrant {\r\n        if(liquiditySent) revert LiquidityAlreadySent();\r\n        // uint256 pricePerToken = calculatePrice();\r\n        \r\n        uint256 totalCost = calculateNumberOfTokensToBuyWithTokens(ethPaid, amount); // in ETH\r\n\r\n\t\tuint256 fee = (totalCost * transactionFeePercent) / 10000; //in ETH\r\n        uint256 netAmount = totalCost + fee;// in ETH\r\n\r\n        if (totalCost > maxBuy) revert ExceededMaxBuy(maxBuy);\r\n\r\n        if (msg.value < netAmount) revert InsufficientETH(msg.value, netAmount);        \r\n\r\n        if (amount > balanceOf(address(this))) revert InsufficientTokens(balanceOf(address(this)), amount);\r\n\r\n        uint256 initialCost = calculateNumberOfTokensToBuyWithTokens( amount); // in ETH;\r\n\r\n\t\t\r\n        if (totalCost > initialCost * (10000 + maxSlippagePercent) / 10000) {\r\n            revert SlippageExceeded(totalCost, initialCost);\r\n        }\r\n\r\n        payable(feeAddress).transfer(fee);\r\n        _transfer(address(this), msg.sender, amount);\r\n\r\n        ethPaid+= totalCost;\r\n        netBoughtTokens += amount; // Increase net bought tokens\r\n        // emit BoughtToken(msg.sender, amount);\r\n        popCoinFactory.notifyTrade(msg.sender, address(this),0, amount, netAmount );\r\n\r\n        // Refund any excess ETH sent\r\n        if (msg.value > netAmount) {\r\n            payable(msg.sender).transfer(msg.value - netAmount);\r\n        }\r\n\r\n        // Deploy liquidity if the target market cap is reached\r\n        if (address(this).balance >= targetMarketCap) {\r\n            _sendLiquidity();\r\n        }\r\n    }\r\n\r\n    // Function to sell tokens by specifying the amount of tokens\r\n    function sell(uint256 amount /*, uint maxSlippagePercent*/) external nonReentrant {\r\n        if(liquiditySent) revert LiquidityAlreadySent();\r\n        // uint256 pricePerToken = calculatePrice();\r\n        uint256 totalReward = calculateNumberOfETHSoldForToken(amount); // pricePerToken * amount;\r\n\r\n        if (address(this).balance < totalReward) revert InsufficientContractETH(address(this).balance, totalReward);\r\n\r\n        uint256 fee = (totalReward * transactionFeePercent) / 10000;\r\n        uint256 netReward = totalReward - fee;\r\n\r\n\t\t// uint256 finalPricePerToken = calculatePrice();\r\n        // if (finalPricePerToken > pricePerToken * (10000 + maxSlippagePercent) / 10000) {\r\n        //     revert SlippageExceeded(finalPricePerToken, pricePerToken * (10000 + maxSlippagePercent) / 10000);\r\n        // }\r\n\r\n        _transfer(msg.sender, address(this), amount);\r\n        payable(feeAddress).transfer(fee);\r\n        payable(msg.sender).transfer(netReward);\r\n        console.log('netBoughtTokens: %d',netBoughtTokens);\r\n        popCoinFactory.notifyTrade(msg.sender, address(this),1, amount, totalReward );\r\n        ethPaid-= totalReward;\r\n        netBoughtTokens -= amount; // Decrease net bought tokens\r\n\r\n        \r\n    }\r\n\r\n    // // Function to sell tokens by specifying the ETH amount desired\r\n    // function sellWithETH(uint256 amount, uint maxSlippagePercent/* x 100  */) external nonReentrant {\r\n    //     if(liquiditySent) revert LiquidityAlreadySent();\r\n    //     if (address(this).balance < amount) revert InsufficientContractETH(address(this).balance, amount);\r\n\r\n    //     uint256 pricePerToken = calculatePrice();\r\n    //     uint256 tokensToSell = amount / pricePerToken;\r\n\r\n    //     uint256 totalReward = pricePerToken * tokensToSell;\r\n    //     uint256 fee = (totalReward * transactionFeePercent) / 10000;\r\n    //     uint256 netReward = totalReward - fee;\r\n\r\n    //     if (balanceOf(msg.sender) < tokensToSell) revert BalanceExceeded(balanceOf(msg.sender), tokensToSell);\r\n\r\n\t// \t// Recalculate price to check slippage\r\n    //     uint256 finalPricePerToken = calculatePrice();\r\n    //     if (finalPricePerToken < pricePerToken * (10000 - maxSlippagePercent) / 10000) {\r\n    //         revert SlippageExceeded(finalPricePerToken, pricePerToken * (10000 - maxSlippagePercent) / 10000);\r\n    //     }\r\n\r\n    //     _transfer(msg.sender, address(this), tokensToSell);\r\n    //     payable(feeAddress).transfer(fee);\r\n    //     payable(msg.sender).transfer(netReward);\r\n\r\n    //     netBoughtTokens -= tokensToSell; // Decrease net bought tokens\r\n    // }\r\n\r\n\t//Todo - Check calculations for tokenAmount\r\n    // function _sendLiquidity() internal {\r\n    //     if (!liquiditySent && address(this).balance >= targetMarketCap) {\r\n    //         uint256 liquidityAmount = (address(this).balance * liquidityDeploymentPercent) / 10000;\r\n\t// \t\tuint256 tokenAmount = calculateNumberOfTokensToBuy(liquidityAmount);\r\n    //         uint256 pricePerToken = calculateNumberOfTokensToBuy(1 ether);\r\n\t// \t\t// uint256 tokenAmount = pricePerToken * liquidityAmount ;\r\n\r\n    //         console.log(\r\n    //             \"liq %d , pricePerToken %d tokenAmount %d tokens\",\r\n    //             liquidityAmount,\r\n    //             pricePerToken,\r\n    //             tokenAmount\r\n    //         );\r\n\r\n    //         IDexFactory factory = IDexFactory(v2Router.factory());\r\n    //         address lpTokenPairAddress = factory.getPair(address(this), v2Router.WETH());\r\n    //         if (lpTokenPairAddress == address(0)) {\r\n    //             lpTokenPairAddress = factory.createPair(address(this), v2Router.WETH());\r\n    //         }\r\n            \r\n\t// \t\t_approve(address(this), address(v2Router), MAX_INT);//tokenAmount\r\n    //         _approve(address(this), lpTokenPairAddress, MAX_INT);//tokenAmount\r\n\r\n    //         // payable(routerAddress).transfer(liquidityAmount);\r\n\r\n\t// \t\tv2Router.addLiquidityETH{ value: liquidityAmount }(\r\n\t// \t\t\taddress(this),\r\n\t// \t\t\ttokenAmount,    \r\n\t// \t\t\t0,\r\n\t// \t\t\t0,\r\n\t// \t\t\tfeeAddress, //test\r\n\t// \t\t\tblock.timestamp + 1200 //20 minutes from now\r\n\t// \t\t);\r\n\r\n    //         liquiditySent=true;\r\n    //     }\r\n    // }\r\n\r\n    function _sendLiquidity() internal {\r\n        if (!liquiditySent && address(this).balance >= targetMarketCap) {\r\n            \r\n            //Send all remaining fund to liquidity\r\n            uint256 liquidityAmount =  address(this).balance - deployLiquidityFee;\r\n\r\n            payable(feeAddress).transfer(deployLiquidityFee);\r\n            \r\n            uint currentTokenBalance = balanceOf(address(this));\r\n\r\n            //Mint 200m tokens to add\r\n\t\t\tuint256 tokenAmount = 200_000_000 ether;\r\n            _mint(address(this), tokenAmount);\r\n            \r\n            console.log('currentTokenBalance %d , tokenAmount %d', currentTokenBalance, tokenAmount);\r\n            console.log('new bal mint %d ', balanceOf(address(this)));\r\n            if(currentTokenBalance>=0){//use balance if more than 200m\r\n                tokenAmount+=currentTokenBalance;\r\n            }\r\n\r\n            uint256 pricePerToken = liquidityAmount/tokenAmount;\r\n\t\t\t// uint256 tokenAmount = pricePerToken * liquidityAmount ;\r\n\r\n            console.log(\r\n                \"liq %d , pricePerToken %d tokenAmount %d tokens\",\r\n                liquidityAmount,\r\n                pricePerToken,\r\n                tokenAmount\r\n            );\r\n\r\n            IDexFactory factory = IDexFactory(v2Router.factory());\r\n            address lpTokenPairAddress = factory.getPair(address(this), v2Router.WETH());\r\n            if (lpTokenPairAddress == address(0)) {\r\n                lpTokenPairAddress = factory.createPair(address(this), v2Router.WETH());\r\n            }\r\n            \r\n\t\t\t_approve(address(this), address(v2Router), MAX_INT);//tokenAmount\r\n            _approve(address(this), lpTokenPairAddress, MAX_INT);//tokenAmount\r\n\r\n            // payable(routerAddress).transfer(liquidityAmount);\r\n\r\n\t\t\t(,, uint256 liquidity) = v2Router.addLiquidityETH{ value: liquidityAmount }(\r\n\t\t\t\taddress(this),\r\n\t\t\t\ttokenAmount,    \r\n\t\t\t\t0,\r\n\t\t\t\t0,\r\n\t\t\t\taddress(this), // feeAddress, //test\r\n\t\t\t\tblock.timestamp + 1200 //20 minutes from now\r\n\t\t\t);\r\n\r\n            liquiditySent=true;\r\n\r\n            //TODO: Burn LP Tokens\r\n            // // Get the LP token (pair) address\r\n            // address pair = factory.getPair(address(this), v2Router.WETH());\r\n            // require(pair != address(0), \"Pair not found\");\r\n\r\n            // console.log('inital pair address: %s, final pair: %s', lpTokenPairAddress, pair);\r\n\r\n            \r\n\r\n            // uint newBalance =IERC20(lpTokenPairAddress).balanceOf(address(this));\r\n\r\n            // console.log('liquidity: %d, newBalance: %d', liquidity, newBalance);\r\n\r\n            // Transfer the LP tokens to the burn address\r\n            require(IERC20(lpTokenPairAddress).transfer(BURN_ADDRESS, liquidity), \"Burn LP tokens failed\");\r\n        }\r\n    }\r\n\r\n\t\r\n\r\n\tfunction withdraw(address payable _to, uint256 _amount) public onlyOwner {\r\n        if(!liquiditySent){\r\n            revert('LiqdtyUnsent');\r\n        }\r\n        require(_amount <= payable(address(this)).balance);\r\n        safeTransferETH(_to, _amount);\r\n    }\r\n\r\n\tfunction safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{ value: value }(new bytes(0));\r\n        require(success, \"TransferHelper::safeTransferETH: ETH transfer failed\");\r\n    }\r\n\r\n    // Fallback function to receive ETH\r\n    receive() external payable {}\r\n}\r\n\r\n"
    },
    "contracts/IDexRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\ninterface IDexRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    \r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external  returns (uint amountA, uint amountB, uint liquidity) ;\r\n\r\n\r\n\t\r\n    \r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\t\r\n\t\r\n\tfunction swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\t\r\n\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n\t// Identical to swapExactTokensForTokens, but succeeds for tokens that take a fee on transfer.\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    \r\n}\r\n\r\ninterface IDexFactory {\r\n    function getPair(address token0, address token1) external view returns (address);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n"
    },
    "contracts/Interfaces/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity >0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IERC2612Standalone.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ninterface IERC2612 is IERC2612Standalone, IERC20 {\n\n}\n"
    },
    "contracts/Interfaces/IERC2612Standalone.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity >0.8.17;\n\ninterface IERC2612Standalone {\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\tfunction nonces(address owner) external view returns (uint256);\n\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/IUniswapRouter.sol": {
      "content": "pragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(\r\n        uint amountIn,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(\r\n        uint amountOut,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(\r\n        uint amountOut,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n}\r\n\r\n// pragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}"
    },
    "contracts/Libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity >0.8.17;\n\nlibrary Constants {\n\tuint256 internal constant UINT256_MAX = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\tuint256 internal constant DECIMALS_18 = 1000000000000000000;\n}\n"
    },
    "contracts/Libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nlibrary Errors {\r\n\terror WrongCurrency();\r\n\r\n\terror INVALIDNFT();\r\n\r\n\terror CurrencySendFailure();\r\n\r\n\terror NotEnoughMoney();\r\n}\r\n"
    },
    "contracts/Libraries/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nlibrary Types {\r\n\tenum EventTypes {\r\n\t\tSELL,\r\n\t\tBUY\r\n\t}\r\n}\r\n"
    },
    "contracts/Lock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\n\ncontract Lock {\n    uint public unlockTime;\n    address payable public owner;\n\n    event Withdrawal(uint amount, uint when);\n\n    constructor(uint _unlockTime) payable {\n        require(\n            block.timestamp < _unlockTime,\n            \"Unlock time should be in the future\"\n        );\n\n        unlockTime = _unlockTime;\n        owner = payable(msg.sender);\n    }\n\n    function withdraw() public {\n        // Uncomment this line, and the import of \"hardhat/console.sol\", to print a log in your terminal\n        // console.log(\"Unlock time is %o and block timestamp is %o\", unlockTime, block.timestamp);\n\n        require(block.timestamp >= unlockTime, \"You can't withdraw yet\");\n        require(msg.sender == owner, \"You aren't the owner\");\n\n        emit Withdrawal(address(this).balance, block.timestamp);\n\n        owner.transfer(address(this).balance);\n    }\n}\n"
    },
    "contracts/Oracles/ISupraSValueFeed.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\r\npragma solidity ^0.8.26;\r\n\r\ninterface ISupraSValueFeed {\r\n\r\n    // Data structure to hold the pair data\r\n    struct priceFeed {\r\n        uint256 round;\r\n        uint256 decimals;\r\n        uint256 time;\r\n        uint256 price;\r\n    }\r\n\r\n\r\n    // Data structure to hold the derived/connverted data pairs.  This depends on your requirements.\r\n\r\n    struct derivedData{\r\n        int256 roundDifference;\r\n        uint256 derivedPrice;\r\n        uint256 decimals;\r\n    }\r\n\r\n\r\n    // Below functions enable you to retrieve different flavours of S-Value\r\n    // Term \"pair ID\" and \"Pair index\" both refer to the same, pair index mentioned in our data pairs list.\r\n\r\n    // Function to retrieve the data for a single data pair\r\n    function getSvalue(uint256 _pairIndex)\r\n        external \r\n        view\r\n        returns (priceFeed memory);\r\n\r\n\r\n\r\n    //Function to fetch the data for a multiple data pairs\r\n    function getSvalues(uint256[] memory _pairIndexes)\r\n        external\r\n        view\r\n        returns (priceFeed[] memory);\r\n\r\n\r\n    // Function to convert and derive new data pairs using two pair IDs and a mathematical operator multiplication(*) or division(/).\r\n    //** Curreently only available in testnets\r\n    function getDerivedSvalue(uint256 pair_id_1,uint256 pair_id_2,\r\n        uint256 operation)\r\n        external\r\n        view\r\n        returns (derivedData memory);\r\n\r\n\r\n\r\n    // Function to check  the latest Timestamp on which a data pair is updated. This will help you check the staleness of a data pair before performing an action. \r\n    function getTimestamp(uint256 _tradingPair) \r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n}"
    },
    "contracts/Oracles/SupraPUSHOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\r\npragma solidity ^0.8.26;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./ISupraSValueFeed.sol\";\r\n\r\n\r\n\r\ncontract SupraPUSHOracle is Ownable {\r\n    error InvalidPair();\r\n    \r\n\r\n    ISupraSValueFeed private sValueFeed; // pointer to supra router\r\n    \r\n\r\n\r\n    address public supraValueFeedAddress ; // router address for  Supra\r\n\r\n\r\n    //GAS_USDT\r\n    mapping(uint => bool) isValidPair;\r\n    \r\n\r\n    event WhitelistPair(address indexed caller, uint[] ratePairs);\r\n    event BlackListPair(address indexed caller, uint[] ratePairs);\r\n\r\n\r\n    constructor(address _supraValueFeedAddress, uint[] memory ratePairIndexes) Ownable(msg.sender) {\r\n        supraValueFeedAddress= _supraValueFeedAddress;\r\n        whitelistSupraPair(ratePairIndexes);\r\n        sValueFeed = ISupraSValueFeed(supraValueFeedAddress);\r\n    }\r\n\r\n\r\n    function whitelistSupraPair(uint[] memory pairs) public onlyOwner {\r\n        uint256 len = pairs.length;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            isValidPair[pairs[i]] = true;\r\n        }\r\n        emit WhitelistPair(msg.sender, pairs);\r\n    }\r\n\r\n    function blacklistSupraPair(uint[] memory pairs) public onlyOwner {\r\n        uint256 len = pairs.length;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            isValidPair[pairs[i]] = false;\r\n        }\r\n        emit BlackListPair(msg.sender, pairs);\r\n    }\r\n\r\n\r\n    \r\n    function getPrice(uint256 _priceIndex)\r\n        public\r\n        view\r\n        returns (ISupraSValueFeed.priceFeed memory)\r\n    {\r\n        require(isValidPair[_priceIndex], InvalidPair());\r\n        return sValueFeed.getSvalue(_priceIndex);\r\n    }\r\n\r\n    function getPrices(uint256[] memory _priceIndexes)\r\n        public\r\n        view\r\n        returns (ISupraSValueFeed.priceFeed[] memory)\r\n    {\r\n        for (uint i = 0; i < _priceIndexes.length; i++) {\r\n            require(isValidPair[_priceIndexes[i]], InvalidPair());\r\n        }\r\n        \r\n        return sValueFeed.getSvalues(_priceIndexes);\r\n    }\r\n\r\n    function updateSupraSvalueFeed(ISupraSValueFeed _newSValueFeed) external onlyOwner {\r\n        sValueFeed = _newSValueFeed;\r\n    }\r\n\r\n}"
    },
    "contracts/PopCoinFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.26;\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./FunToken.sol\";\r\n\r\nerror NotEnoughFee(uint feeToPay);\r\nerror NotEnoughBalance(uint balance);\r\nerror UnsupportedRouter();\r\n\r\ncontract PopCoinFactory is Ownable {\r\n\r\n    event TokenCreated(address creator, address tokenAddress);\r\n\r\n    event TokenTraded(\r\n        address indexed trader, \r\n        address indexed tokenAddress, \r\n        uint indexed tradeType,  //0 for Buy, 1 for Sell\r\n        uint tokensTraded, \r\n        uint amountPaid\r\n    );\r\n    \r\n    mapping(address => address[]) public ownerTokens;\r\n\r\n    mapping(address => address) public tokenCreators; // token -> creator\r\n\r\n    uint public tokenCount;\r\n\r\n    address[] public tokens;\r\n\r\n    address private adminPaymentAddress;\r\n\r\n    uint public fee = 0.0005 ether;\r\n    uint public targetMarketCap=30 ether;\r\n\r\n    uint256 deployLiquidityFee=1.5 ether; \r\n\r\n    uint256 liquidityAmount=6 ether; \r\n\r\n    uint256 public transactionFeePercent=100; // Fee percentage for buy and sell - 1%\r\n    \r\n\r\n    mapping(address => bool) public routersSupported; \r\n    \r\n\r\n    constructor(address[4] memory _dexRouterAddresses) Ownable(msg.sender) {\r\n        adminPaymentAddress=msg.sender;\r\n        // dexRouterAddress=_dexRouterAddress;\r\n\r\n        for(uint i=0; i< _dexRouterAddresses.length; i++){\r\n            if(_dexRouterAddresses[i]!= address(0)){\r\n                routersSupported[_dexRouterAddresses[i]]= true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function switchDexRouterSupport(address _dexRouterAddress, bool supported) public onlyOwner {\r\n        if(_dexRouterAddress!= address(0)){\r\n            routersSupported[_dexRouterAddress]= supported;\r\n        }\r\n    }\r\n\r\n\r\n    // \r\n    function createToken(string memory name,string memory symbol,uint _initialBuyInEth, address dexRouterAddress) public payable {\r\n\r\n        if(msg.value<fee+_initialBuyInEth) revert NotEnoughFee(fee);\r\n\r\n        if(!routersSupported[dexRouterAddress]) revert UnsupportedRouter();\r\n                \r\n        FunToken token = new FunToken(name, symbol, targetMarketCap,transactionFeePercent, adminPaymentAddress,  20, dexRouterAddress, msg.sender,_initialBuyInEth, deployLiquidityFee, liquidityAmount );\r\n        address tokenAddress = address(token);\r\n\r\n        if(_initialBuyInEth>0){\r\n            (bool success, ) = tokenAddress.call{value: _initialBuyInEth}(\"\");\r\n            require(success, \"Transfer InitialEth failed\");\r\n        }\r\n        \r\n        ownerTokens[msg.sender].push(tokenAddress);\r\n        tokenCreators[tokenAddress]=msg.sender;\r\n        tokens.push(tokenAddress);\r\n\r\n\r\n        \r\n        emit TokenCreated(msg.sender, tokenAddress);\r\n        tokenCount++;       \r\n\r\n    }\r\n\r\n\r\n    function  getTokens(uint skip, uint take) public view returns(address[] memory) {\r\n        address[] memory list = new address[](take) ;\r\n        for (uint256 i=skip; i < skip + take ; i++) {\r\n            list[i-skip] = tokens[i]; \r\n        }\r\n        return list;\r\n    }\r\n\r\n    \r\n\r\n   \r\n   function  getOwnerTokensCount(address owner) public view returns(uint) {\r\n        \r\n        return ownerTokens[owner].length;\r\n    }\r\n\r\n    function  getTokenCreator(address token) public view returns(address) {\r\n        \r\n        return tokenCreators[token];\r\n    }\r\n\r\n    function  getOwnerTokens(address owner,uint skip, uint take) public view returns(address[] memory) {\r\n        address[] memory list = new address[](take) ;\r\n        for (uint256 i=skip; i < skip + take ; i++) {\r\n            list[i-skip] = ownerTokens[owner][i]; \r\n        }\r\n        return list;\r\n    }\r\n\r\n    function  changeAdminPaymentAddress(address newAdminPaymentAddress) public onlyOwner  {\r\n        \r\n        adminPaymentAddress = newAdminPaymentAddress;\r\n    }\r\n\r\n    function  changeFee(uint newFee) public onlyOwner  {\r\n        \r\n        fee = newFee;\r\n    }\r\n\r\n    function  changeDeployLiquidityFee(uint newFee) public onlyOwner  {\r\n        \r\n        deployLiquidityFee = newFee;\r\n    }\r\n\r\n    function  changeLiquidityAmount(uint newAmount) public onlyOwner  {\r\n        \r\n        liquidityAmount = newAmount;\r\n    }\r\n\r\n    function  withdrawFrom(FunToken funToken, uint amount) public onlyOwner  {\r\n        \r\n        funToken.withdraw(payable(msg.sender), amount);\r\n    }\r\n\r\n\r\n    function  withdrawFee(address to, uint amount) public onlyOwner  {\r\n        \r\n        uint balance = address(this).balance;\r\n        if(amount>=balance){\r\n            if(to==address(0)){\r\n                to=adminPaymentAddress;\r\n            }\r\n\r\n            payable(to).transfer(amount);\r\n        }else {\r\n            revert NotEnoughBalance(balance);\r\n        }\r\n    }\r\n\r\n    \r\n    function notifyTrade(address trader, address tokenAddress, uint tradeType, uint tokensTraded, uint amountPaid) public {\r\n        if(tokenAddress!= msg.sender || tokenCreators[tokenAddress]==address(0)){// token is not issued by Factory\r\n            revert('Token Not Issued by Factory');\r\n        }\r\n\r\n        emit TokenTraded(trader,tokenAddress,tradeType,tokensTraded,amountPaid);\r\n    }\r\n}"
    },
    "contracts/Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.13;\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ncontract Test{\r\n\r\n    using SafeERC20 for ERC20;\r\n\r\n    uint public posCount;\r\n\r\n   \r\n\r\n    constructor(){\r\n        \r\n    }\r\n\r\n\r\n    \r\n    function t() public {\r\n        posCount++;       \r\n\r\n    }\r\n\r\n    \r\n\r\n   \r\n\r\n    function  r() public view returns(uint) {\r\n        return posCount;\r\n    }\r\n\r\n    \r\n\r\n    function  testPay(address tokenAddress) public  {\r\n        ERC20 token = ERC20(tokenAddress);\r\n        token.safeTransferFrom(msg.sender, address(this),  (10**token.decimals()) / 10000000 );\r\n    }\r\n\r\n    \r\n\r\n\r\n}"
    },
    "contracts/TestToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\r\npragma solidity ^0.8.23;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract TestToken is ERC20 {\r\n\tuint8 decimalPlaces;\r\n\r\n\tconstructor(string memory name, string memory symbol,  uint8 _decimals) ERC20(name, symbol) {\r\n\t\tdecimalPlaces=_decimals;\r\n\r\n\t\t_mint(msg.sender, 100000000 * 10 ** decimalPlaces);\r\n\t\t_mint(0xa55980aB0C3aeFB871af97462CdbBECB41aEed09, 10000 * 10 ** decimalPlaces);\r\n\t\t_mint (0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, 10000 * 10 ** decimalPlaces);\r\n\r\n\t\t_mint(0x70997970C51812dc3A010C7d01b50e0d17dc79C8, 10000 * 10 ** decimalPlaces);\r\n\t\t_mint (0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC, 10000 * 10 ** decimalPlaces);\r\n\t}\r\n\r\n\r\n\r\n\tfunction giveMe(uint256 amount) public {\r\n\t\t_mint(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction decimals() public view virtual override returns (uint8) {\r\n\t\treturn decimalPlaces;\r\n\t}\r\n}\r\n"
    },
    "contracts/V2/FunToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\r\npragma solidity ^0.8.23;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n// import \"../IDexRouter.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\n\r\nimport { ERC20Permit, ERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\r\nerror OnlyPopCoinFactory();\r\nerror NotApprovable();\r\n\r\n\r\ncontract FunTokenV2 is ERC20Permit {\r\n    \r\n    \r\n    address public immutable creator;\r\n    \r\n\tuint8 decimalPlaces=18;\r\n    address public routerAddress;                     // Address of the DEX to deploy liquidity to\r\n    address popCoinFactoryAddress;\r\n    /// @notice Prevent trading on AMMs until liquidity migration\r\n    bool public isApprovable = false;\r\n\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        address _popCoinFactoryAddress,\r\n        address _creator,\r\n        uint256 _supply,\r\n        address _routerAddress\r\n    ) ERC20(name, symbol) ERC20Permit(name) {\r\n        \r\n        popCoinFactoryAddress=_popCoinFactoryAddress;\r\n        creator = _creator;\r\n\r\n        routerAddress = _routerAddress;\r\n\t\t// v2Router = IDexRouter(_routerAddress);\r\n        _mint(msg.sender, _supply);\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        if (spender == popCoinFactoryAddress || isApprovable) return super.approve(spender, amount);\r\n        revert NotApprovable();\r\n    }\r\n\r\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public override {\r\n        if (!isApprovable) revert NotApprovable();\r\n        super.permit(owner, spender, value, deadline, v, r, s);\r\n    }\r\n\r\n    function setIsApprovable(bool _val) public {\r\n        if (msg.sender != popCoinFactoryAddress) revert OnlyPopCoinFactory();\r\n        isApprovable = _val;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n\t\treturn decimalPlaces;\r\n\t}\r\n}\r\n\r\n\r\n// contract FunToken is ERC20 {\r\n    \r\n\r\n\t\r\n// \tuint8 decimalPlaces=18;\r\n//     uint256 public targetMarketCap;                // Target market cap in wei\r\n//     uint256 public transactionFeePercent;                     // Fee percentage for transactions (in basis points)\r\n//     address public feeAddress;                     // Address to receive transaction fees\r\n//     uint256 public liquidityDeploymentPercent;     // Percentage of liquidity to deploy to DEX\r\n    \r\n//     uint256 public immutable fixedSupply=1_000_000_000 ether;          // Fixed supply of the token\r\n//     uint256 public immutable initialFixedSupply=800_000_000 ether;          // Fixed supply of the token\r\n\r\n//     uint256 public netBoughtTokens;                // Tracks the net amount of tokens bought\r\n//     uint256 public ethPaid; \r\n// \tuint256 public maxBuy = 5 ether;\r\n//     uint256 deployLiquidityFee=5 ether; \r\n\r\n//     // address popCoinFactory;\r\n//     IPopCoinFactory popCoinFactory;\r\n\r\n//     bool public liquiditySent = false;\r\n\r\n//     uint256 constant private MAX_INT = 2**256 - 1;\r\n\r\n//      // Constants derived from the fitting y=f- t/(k+x) where x=supply in Sale Coin\r\n//     uint256 private constant F = 1071000120;\r\n//     uint256 private constant T = 11229068400;\r\n//     uint256 private constant K = 10.48465702 ether;  // 10.48465702\r\n\r\n//     // event BoughtToken(address indexed buyer, uint amountPaid);\r\n//     // event SoldToken(address indexed buyer, uint amountPaid);\r\n//     event LiquidityDeployed();\r\n\r\n    \r\n//     uint256 private constant PRECISION = 10**18; // To maintain precision for Ether and token calculations\r\n\r\n//     uint256 public liquidityAmount;\r\n//     //todo\r\n//     //resrtrict owner withdrawal until coins have been moved to DEX\r\n\r\n//     constructor(\r\n//         string memory name,\r\n//         string memory symbol,        \r\n//         uint256 _targetMarketCap,\r\n//         uint256 _transactionFeePercent,\r\n//         address _feeAddress,\r\n//         uint256 _liquidityDeploymentPercent,\r\n//         address _routerAddress,\r\n// \t\taddress _creator,\r\n// \t\tuint _initialBuyInEth,\r\n//         uint256 _deployLiquidityFee,\r\n//         uint256 _liquidityAmount\r\n//     ) ERC20(name, symbol) Ownable(_creator) {\r\n//         popCoinFactory=IPopCoinFactory( msg.sender);\r\n//         targetMarketCap = _targetMarketCap;\r\n//         transactionFeePercent = _transactionFeePercent;\r\n//         feeAddress = _feeAddress;\r\n//         liquidityDeploymentPercent = _liquidityDeploymentPercent;\r\n//         routerAddress = _routerAddress;\r\n// \t\tv2Router = IDexRouter(_routerAddress);\r\n//         deployLiquidityFee=_deployLiquidityFee;\r\n//         liquidityAmount=_liquidityAmount;\r\n//         // console.log(\"INITIAL ethPaid %d \",ethPaid);\r\n//         // Initially mint the initial fixed supply to the contract itself\r\n// \t\tuint initialTokensForCreator = calculateNumberOfTokensToBuy(_initialBuyInEth);\r\n//         _mint(address(this), initialFixedSupply - initialTokensForCreator);\r\n// \t\t_mint(_creator, initialTokensForCreator);\r\n//         ethPaid+=_initialBuyInEth;\r\n//         netBoughtTokens+=initialTokensForCreator;\r\n//         // console.log(\"INITIAL2 ethPaid %d \",ethPaid);\r\n\r\n//         // console.log(\"creator %s , _initialBuyInEth %d, initialTokensForCreator %d \",_creator, _initialBuyInEth, initialTokensForCreator);\r\n//     }\r\n\r\n// \tfunction decimals() public view virtual override returns (uint8) {\r\n// \t\treturn decimalPlaces;\r\n// \t}\r\n\r\n//     // returns actual no  not scaled t 18 decimals\r\n//     function tokensIssued(uint supplyInEth) public pure returns (uint) {\r\n        \r\n//         // Scale up supplyInEth by the precision factor to maintain accuracy during division\r\n//         uint256 scaledSupply = (supplyInEth * PRECISION) / 10**18; // Now, scaledSupply has the same precision as 1 ETH\r\n\r\n//         // Perform the calculation with scaledSupply\r\n//         // Here, we add the precision factor to 30 to keep the units consistent during the calculation\r\n//         uint256 result = F - T * PRECISION / (K  + scaledSupply);\r\n//         // console.log(\"tokensIssued::  supplyInEth %d, tokens %d \",supplyInEth, result);\r\n//         return result;\r\n//     }\r\n\r\n\r\n//     function price(uint supplyInEth) public pure returns (uint) {\r\n//         uint tokensIssued = tokensIssued(supplyInEth);\r\n\r\n//         return supplyInEth/tokensIssued;\r\n//     }\r\n\r\n//     // Function to calculate the amount of tokens T for given Ether (ETH) paid\r\n//     function calculateNumberOfTokensToBuy( uint256 amount) public view returns (uint256) {\r\n//         return calculateNumberOfTokensToBuy(ethPaid,amount);\r\n//     }\r\n//     // Function to calculate the amount of tokens T for given Ether (ETH) paid\r\n//     function calculateNumberOfTokensToBuy(uint256 totalEthInContract, uint256 amount) public view returns (uint256) {\r\n//         uint256 initialTokens = tokensIssued(totalEthInContract);\r\n//         uint256 newEthTotal = totalEthInContract + amount;\r\n//         uint256 finalTokens = tokensIssued(newEthTotal);\r\n\r\n//         uint256 tokensToIssue = finalTokens - initialTokens;\r\n//         // console.log('newEthTotal %d ',newEthTotal);\r\n//         // console.log('totalEthInContract %d , initialTokens %d , finalTokens %d ',totalEthInContract, initialTokens, finalTokens);\r\n\r\n//         return tokensToIssue * PRECISION;\r\n//     }\r\n\r\n//     // Function to calculate the amount of Ether (ETH) needed to buy a specific number of tokens (T)\r\n//     function calculateNumberOfTokensToBuyWithTokens( uint256 amount) public view returns (uint256) {\r\n//         return calculateNumberOfTokensToBuyWithTokens(ethPaid,amount);\r\n//     }\r\n\r\n//     // Function to calculate the amount of Ether (ETH) needed to buy a specific number of tokens (T)\r\n//     function calculateNumberOfTokensToBuyWithTokens(uint256 totalEthInContract,  uint256 tokensToBuy) public view returns (uint256) {\r\n        \r\n//         uint256 initialTokens = tokensIssued(totalEthInContract);\r\n//         // console.log(\" initialTokens %d, tokensToBuy %d\", initialTokens, tokensToBuy);\r\n//         uint256 targetTokens = (initialTokens*PRECISION + tokensToBuy)/PRECISION;\r\n        \r\n//         // Invert the formula to solve for x (Ether) when we know y (tokens)\r\n//         uint256 targetEth = T * PRECISION / (F - targetTokens) - K;\r\n//         // console.log(\"targetTokens %d, targetEth %d, tokensToBuy %d\",targetTokens, targetEth, tokensToBuy);\r\n\r\n//         uint256 ethNeeded = targetEth  - totalEthInContract;\r\n//         // console.log(\"totalEthInContract %d, realBalance %d, ethNeeded %d\",totalEthInContract, address(this).balance, ethNeeded);\r\n//         return ethNeeded;\r\n//     }\r\n\r\n    \r\n\r\n\r\n//     // Function to calculate the amount of Ether (ETH) returned for selling a certain amount of tokens (T)\r\n//     function calculateNumberOfETHSoldForToken( uint256 tokensToSell) public view returns (uint256) {\r\n//         // console.log(\" ethPaid %d, tokensToSell %d\",ethPaid, tokensToSell);\r\n//         return calculateNumberOfETHSoldForToken(ethPaid,tokensToSell);\r\n//     }\r\n\r\n//     function calculateNumberOfETHSoldForToken(uint256 totalEthInContract,  uint256 tokensToSell) public view returns (uint256) {\r\n//         // console.log(\"SELLING:: tokensToSell %d \", tokensToSell );\r\n//         uint256 initialTokens = tokensIssued(totalEthInContract);\r\n//         // console.log(\"SELLING:: initialTokens %d , totalEthInContract %d \", initialTokens, totalEthInContract );\r\n//         uint256 targetTokens = initialTokens - tokensToSell/PRECISION;\r\n\r\n//         console.log(\"SELLING:: initialTokens %d, tokensToSell %d , targetTokens %d \", initialTokens,tokensToSell, targetTokens );\r\n\r\n//         // // Invert the formula to solve for x (Ether) when we know y (tokens)\r\n//         // // y = F - T / (K + x)\r\n//         // // => T / (K + x) = F - y\r\n//         // // => x = T / (F - y) - K\r\n//         // // console.log(\"SELLING:: T  %d \", (T ) );\r\n//         console.log(\"SELLING:: K  %d, K/PRECISION %d \", K, (K/PRECISION ) );\r\n//         console.log(\"SELLING:: (F - targetTokens) %d \", (F - targetTokens) );\r\n//         console.log(\"SELLING:: (T * PRECISION  / (F - targetTokens)) %d \", (T * PRECISION  / (F - targetTokens)) );\r\n//         uint256 targetEth = (T * PRECISION  / (F - targetTokens)) - (K);\r\n//         console.log(\"SELLING:: totalEthInContract %d, targetEth %d \",totalEthInContract,  targetEth );\r\n//         uint256 ethToReturn = totalEthInContract - targetEth ;\r\n//         console.log(\"SELLING:: ethToReturn %d \", ethToReturn );\r\n\r\n//         return ethToReturn;\r\n//     }\r\n\r\n//     // function calculateNumberOfETHSoldForTokenOld(uint256 totalEthInContract,  uint256 tokensToSell) public view returns (uint256) {\r\n//     //     // console.log(\"SELLING:: tokensToSell %d \", tokensToSell );\r\n//     //     uint256 initialTokens = tokensIssued(totalEthInContract);\r\n//     //     // console.log(\"SELLING:: initialTokens %d , totalEthInContract %d \", initialTokens, totalEthInContract );\r\n//     //     uint256 targetTokens = initialTokens - tokensToSell/PRECISION;\r\n\r\n//     //     // console.log(\"SELLING:: initialTokens %d, tokensToSell %d , targetTokens %d \", initialTokens,tokensToSell, targetTokens );\r\n\r\n//     //     // Invert the formula to solve for x (Ether) when we know y (tokens)\r\n//     //     // y = F - T / (K + x)\r\n//     //     // => T / (K + x) = F - y\r\n//     //     // => x = T / (F - y) - K\r\n//     //     // console.log(\"SELLING:: (T * PRECISION) %d \", (T * PRECISION) );\r\n//     //     // console.log(\"SELLING:: (F - targetTokens) %d \", (F - targetTokens) );\r\n//     //     uint256 targetEth = (T * PRECISION / (F - targetTokens)) - (K);\r\n//     //     console.log(\"SELLING:: targetEth %d \", targetEth );\r\n//     //     uint256 ethToReturn = totalEthInContract - targetEth / PRECISION;\r\n//     //     console.log(\"SELLING:: ethToReturn %d \", ethToReturn );\r\n\r\n//     //     return ethToReturn;\r\n//     // }\r\n\r\n    \r\n\r\n\r\n\r\n\r\n//     // Helper function to calculate exponential in a fixed-point format\r\n//     function exp(uint256 x) internal pure returns (uint256) {\r\n//         // x is expected to be in the fixed-point format with 18 decimal places\r\n//         // We use an approximation for e^x: exp(x) = sum(x^n / n!)\r\n//         // For simplicity and avoiding excessive gas cost, we'll approximate up to 6 terms\r\n\r\n//         uint256 term = x;\r\n//         uint256 result = 1 ether; // e^0 = 1\r\n//         result += term;\r\n\r\n//         term = (term * x) / 1 ether; // x^2 / 2!\r\n//         result += term / 2;\r\n\r\n//         term = (term * x) / 1 ether; // x^3 / 3!\r\n//         result += term / 6;\r\n\r\n//         term = (term * x) / 1 ether; // x^4 / 4!\r\n//         result += term / 24;\r\n\r\n//         term = (term * x) / 1 ether; // x^5 / 5!\r\n//         result += term / 120;\r\n\r\n//         term = (term * x) / 1 ether; // x^6 / 6!\r\n//         result += term / 720;\r\n\r\n//         return result;\r\n//     }\r\n\r\n\r\n//     // Function to buy tokens by specifying the ETH amount\r\n//     function buyWithETH(uint256 amount, uint256 maxSlippagePercent) external payable nonReentrant {\r\n        \r\n\r\n//         if (liquiditySent) revert LiquidityAlreadySent();\r\n//         if (amount > maxBuy) revert ExceededMaxBuy(maxBuy);\r\n//         console.log('amount %d,ethPaid %d,targetMarketCap %d', amount ,ethPaid,targetMarketCap);\r\n//         console.log('amount + ethPaid %d,targetMarketCap %d', amount + ethPaid,targetMarketCap);\r\n//         if(amount + ethPaid>targetMarketCap) revert ExceedsMarketCap();\r\n        \r\n//         uint256 fee = (amount * transactionFeePercent) / 10000;\r\n//         uint256 netAmount = amount + fee;// in ETH\r\n        \r\n//         if (netAmount > msg.value) revert InsufficientETH(msg.value, netAmount);\r\n\r\n//         // Calculate the expected price per token (in ETH)\r\n//         uint256 totalEthInContractBefore = ethPaid;// address(this).balance - msg.value;\r\n//         // uint256 initialTokens = tokensIssued(totalEthInContractBefore);\r\n//         uint256 expectedPricePerToken = amount / calculateNumberOfTokensToBuy(amount);\r\n\r\n        \r\n//         // Calculate the number of tokens expected for the given ETH amount\r\n//         uint256 tokensToBuy = calculateNumberOfTokensToBuy(ethPaid , amount);\r\n//         ethPaid+= amount;\r\n//         console.log('BUYWITHETH:: tokensToBuy %d, expectedPricePerToken: %d', tokensToBuy, expectedPricePerToken);\r\n//         // Check the token balance available for sale\r\n//         if (tokensToBuy > balanceOf(address(this))) revert InsufficientTokens(balanceOf(address(this)), tokensToBuy);\r\n\r\n        \r\n\r\n//         // console.log('initialTokens %d, expectedPricePerToken: %d', initialTokens, expectedPricePerToken);\r\n//         uint currentTokenBalance = balanceOf(address(this));\r\n//         console.log('currentTokenBalance %d , tokensToBuy %d', currentTokenBalance, tokensToBuy);\r\n//         // Perform the token transfer and handle fees\r\n//         payable(feeAddress).transfer(fee);\r\n//         _transfer(address(this), msg.sender, tokensToBuy);\r\n//         netBoughtTokens += tokensToBuy; // Increase net bought tokens\r\n\r\n//         currentTokenBalance = balanceOf(address(this));\r\n//         console.log('currentTokenBalance after %d , tokensToBuy %d', currentTokenBalance, tokensToBuy);\r\n\r\n//         // Calculate the actual price per token after the transaction\r\n//         uint256 totalEthInContractAfter = ethPaid;// address(this).balance;\r\n//         // uint256 finalTokens = tokensIssued(totalEthInContractAfter);\r\n//         uint256 effectivePricePerToken = (totalEthInContractAfter - totalEthInContractBefore) / tokensToBuy;\r\n\r\n//         // console.log('finalTokens %d, effectivePricePerToken: %d', finalTokens, effectivePricePerToken);\r\n//         // Calculate the allowed slippage\r\n//         uint256 maxAllowedSlippage = (expectedPricePerToken * (10000  + maxSlippagePercent)) / 10000 ;\r\n//         // Ensure the effective price does not exceed the maximum allowed price with slippage\r\n//         // require(effectivePricePerToken <= maxAllowedSlippage, \"Slippage too high\");\r\n//         if (effectivePricePerToken > maxAllowedSlippage) {\r\n//             revert SlippageExceeded(effectivePricePerToken, maxAllowedSlippage);\r\n//         }\r\n\r\n//         // emit BoughtToken(msg.sender, amount);\r\n//         popCoinFactory.notifyTrade(msg.sender, address(this),0, tokensToBuy, amount );\r\n//         // console.log('amount/(finalTokens-initialTokens) %d, effectivePricePerToken: %d', amount/(finalTokens-initialTokens), effectivePricePerToken);\r\n//         // console.log('maxAllowedSlippage %d, expectedPricePerToken: %d', maxAllowedSlippage, effectivePricePerToken);\r\n//         // console.log('Real ETH BAl %d, targetMarketCap: %d', address(this).balance, targetMarketCap);\r\n\r\n//         // Deploy liquidity if the target market cap is reached\r\n\r\n//         console.log('address(this).balance %d , netBoughtTokens %d, ethPaid %d', address(this).balance, netBoughtTokens, ethPaid);\r\n//         if (address(this).balance >= targetMarketCap) {\r\n//             _sendLiquidity();\r\n//         }\r\n//     }\r\n\r\n    \r\n//     // Function to buy tokens by specifying the amount of tokens to buy, send cost of buying  plus tx fee\r\n//     function buy(uint256 amount, uint256 maxSlippagePercent) external payable nonReentrant {\r\n//         if(liquiditySent) revert LiquidityAlreadySent();\r\n//         // uint256 pricePerToken = calculatePrice();\r\n        \r\n//         uint256 totalCost = calculateNumberOfTokensToBuyWithTokens(ethPaid, amount); // in ETH\r\n\r\n// \t\tuint256 fee = (totalCost * transactionFeePercent) / 10000; //in ETH\r\n//         uint256 netAmount = totalCost + fee;// in ETH\r\n\r\n//         if (totalCost > maxBuy) revert ExceededMaxBuy(maxBuy);\r\n\r\n//         if (msg.value < netAmount) revert InsufficientETH(msg.value, netAmount);        \r\n\r\n//         if (amount > balanceOf(address(this))) revert InsufficientTokens(balanceOf(address(this)), amount);\r\n\r\n//         uint256 initialCost = calculateNumberOfTokensToBuyWithTokens( amount); // in ETH;\r\n\r\n\t\t\r\n//         if (totalCost > initialCost * (10000 + maxSlippagePercent) / 10000) {\r\n//             revert SlippageExceeded(totalCost, initialCost);\r\n//         }\r\n\r\n//         payable(feeAddress).transfer(fee);\r\n//         _transfer(address(this), msg.sender, amount);\r\n\r\n//         ethPaid+= totalCost;\r\n//         netBoughtTokens += amount; // Increase net bought tokens\r\n//         // emit BoughtToken(msg.sender, amount);\r\n//         popCoinFactory.notifyTrade(msg.sender, address(this),0, amount, netAmount );\r\n\r\n//         // Refund any excess ETH sent\r\n//         if (msg.value > netAmount) {\r\n//             payable(msg.sender).transfer(msg.value - netAmount);\r\n//         }\r\n\r\n//         // Deploy liquidity if the target market cap is reached\r\n//         if (address(this).balance >= targetMarketCap) {\r\n//             _sendLiquidity();\r\n//         }\r\n//     }\r\n\r\n//     // Function to sell tokens by specifying the amount of tokens\r\n//     function sell(uint256 amount /*, uint maxSlippagePercent*/) external nonReentrant {\r\n//         if(liquiditySent) revert LiquidityAlreadySent();\r\n//         // uint256 pricePerToken = calculatePrice();\r\n//         uint256 totalReward = calculateNumberOfETHSoldForToken(amount); // pricePerToken * amount;\r\n\r\n//         if (address(this).balance < totalReward) revert InsufficientContractETH(address(this).balance, totalReward);\r\n\r\n//         uint256 fee = (totalReward * transactionFeePercent) / 10000;\r\n//         uint256 netReward = totalReward - fee;\r\n\r\n// \t\t// uint256 finalPricePerToken = calculatePrice();\r\n//         // if (finalPricePerToken > pricePerToken * (10000 + maxSlippagePercent) / 10000) {\r\n//         //     revert SlippageExceeded(finalPricePerToken, pricePerToken * (10000 + maxSlippagePercent) / 10000);\r\n//         // }\r\n\r\n//         _transfer(msg.sender, address(this), amount);\r\n//         payable(feeAddress).transfer(fee);\r\n//         payable(msg.sender).transfer(netReward);\r\n//         console.log('netBoughtTokens: %d',netBoughtTokens);\r\n//         popCoinFactory.notifyTrade(msg.sender, address(this),1, amount, totalReward );\r\n//         ethPaid-= totalReward;\r\n//         netBoughtTokens -= amount; // Decrease net bought tokens\r\n\r\n        \r\n//     }\r\n\r\n//     // // Function to sell tokens by specifying the ETH amount desired\r\n//     // function sellWithETH(uint256 amount, uint maxSlippagePercent/* x 100  */) external nonReentrant {\r\n//     //     if(liquiditySent) revert LiquidityAlreadySent();\r\n//     //     if (address(this).balance < amount) revert InsufficientContractETH(address(this).balance, amount);\r\n\r\n//     //     uint256 pricePerToken = calculatePrice();\r\n//     //     uint256 tokensToSell = amount / pricePerToken;\r\n\r\n//     //     uint256 totalReward = pricePerToken * tokensToSell;\r\n//     //     uint256 fee = (totalReward * transactionFeePercent) / 10000;\r\n//     //     uint256 netReward = totalReward - fee;\r\n\r\n//     //     if (balanceOf(msg.sender) < tokensToSell) revert BalanceExceeded(balanceOf(msg.sender), tokensToSell);\r\n\r\n// \t// \t// Recalculate price to check slippage\r\n//     //     uint256 finalPricePerToken = calculatePrice();\r\n//     //     if (finalPricePerToken < pricePerToken * (10000 - maxSlippagePercent) / 10000) {\r\n//     //         revert SlippageExceeded(finalPricePerToken, pricePerToken * (10000 - maxSlippagePercent) / 10000);\r\n//     //     }\r\n\r\n//     //     _transfer(msg.sender, address(this), tokensToSell);\r\n//     //     payable(feeAddress).transfer(fee);\r\n//     //     payable(msg.sender).transfer(netReward);\r\n\r\n//     //     netBoughtTokens -= tokensToSell; // Decrease net bought tokens\r\n//     // }\r\n\r\n// \t//Todo - Check calculations for tokenAmount\r\n//     // function _sendLiquidity() internal {\r\n//     //     if (!liquiditySent && address(this).balance >= targetMarketCap) {\r\n//     //         uint256 liquidityAmount = (address(this).balance * liquidityDeploymentPercent) / 10000;\r\n// \t// \t\tuint256 tokenAmount = calculateNumberOfTokensToBuy(liquidityAmount);\r\n//     //         uint256 pricePerToken = calculateNumberOfTokensToBuy(1 ether);\r\n// \t// \t\t// uint256 tokenAmount = pricePerToken * liquidityAmount ;\r\n\r\n//     //         console.log(\r\n//     //             \"liq %d , pricePerToken %d tokenAmount %d tokens\",\r\n//     //             liquidityAmount,\r\n//     //             pricePerToken,\r\n//     //             tokenAmount\r\n//     //         );\r\n\r\n//     //         IDexFactory factory = IDexFactory(v2Router.factory());\r\n//     //         address lpTokenPairAddress = factory.getPair(address(this), v2Router.WETH());\r\n//     //         if (lpTokenPairAddress == address(0)) {\r\n//     //             lpTokenPairAddress = factory.createPair(address(this), v2Router.WETH());\r\n//     //         }\r\n            \r\n// \t// \t\t_approve(address(this), address(v2Router), MAX_INT);//tokenAmount\r\n//     //         _approve(address(this), lpTokenPairAddress, MAX_INT);//tokenAmount\r\n\r\n//     //         // payable(routerAddress).transfer(liquidityAmount);\r\n\r\n// \t// \t\tv2Router.addLiquidityETH{ value: liquidityAmount }(\r\n// \t// \t\t\taddress(this),\r\n// \t// \t\t\ttokenAmount,    \r\n// \t// \t\t\t0,\r\n// \t// \t\t\t0,\r\n// \t// \t\t\tfeeAddress, //test\r\n// \t// \t\t\tblock.timestamp + 1200 //20 minutes from now\r\n// \t// \t\t);\r\n\r\n//     //         liquiditySent=true;\r\n//     //     }\r\n//     // }\r\n\r\n//     function _sendLiquidity() internal {\r\n//         if (!liquiditySent && address(this).balance >= targetMarketCap) {\r\n            \r\n//             //Send all remaining fund to liquidity\r\n//             uint256 liquidityAmount =  address(this).balance - deployLiquidityFee;\r\n\r\n//             payable(feeAddress).transfer(deployLiquidityFee);\r\n            \r\n//             uint currentTokenBalance = balanceOf(address(this));\r\n\r\n//             //Mint 200m tokens to add\r\n// \t\t\tuint256 tokenAmount = 200_000_000 ether;\r\n//             _mint(address(this), tokenAmount);\r\n            \r\n//             console.log('currentTokenBalance %d , tokenAmount %d', currentTokenBalance, tokenAmount);\r\n//             console.log('new bal mint %d ', balanceOf(address(this)));\r\n//             if(currentTokenBalance>=0){//use balance if more than 200m\r\n//                 tokenAmount+=currentTokenBalance;\r\n//             }\r\n\r\n//             uint256 pricePerToken = liquidityAmount/tokenAmount;\r\n// \t\t\t// uint256 tokenAmount = pricePerToken * liquidityAmount ;\r\n\r\n//             console.log(\r\n//                 \"liq %d , pricePerToken %d tokenAmount %d tokens\",\r\n//                 liquidityAmount,\r\n//                 pricePerToken,\r\n//                 tokenAmount\r\n//             );\r\n\r\n//             IDexFactory factory = IDexFactory(v2Router.factory());\r\n//             address lpTokenPairAddress = factory.getPair(address(this), v2Router.WETH());\r\n//             if (lpTokenPairAddress == address(0)) {\r\n//                 lpTokenPairAddress = factory.createPair(address(this), v2Router.WETH());\r\n//             }\r\n            \r\n// \t\t\t_approve(address(this), address(v2Router), MAX_INT);//tokenAmount\r\n//             _approve(address(this), lpTokenPairAddress, MAX_INT);//tokenAmount\r\n\r\n//             // payable(routerAddress).transfer(liquidityAmount);\r\n\r\n// \t\t\t(,, uint256 liquidity) = v2Router.addLiquidityETH{ value: liquidityAmount }(\r\n// \t\t\t\taddress(this),\r\n// \t\t\t\ttokenAmount,    \r\n// \t\t\t\t0,\r\n// \t\t\t\t0,\r\n// \t\t\t\taddress(this), // feeAddress, //test\r\n// \t\t\t\tblock.timestamp + 1200 //20 minutes from now\r\n// \t\t\t);\r\n\r\n//             liquiditySent=true;\r\n\r\n//             //TODO: Burn LP Tokens\r\n//             // // Get the LP token (pair) address\r\n//             // address pair = factory.getPair(address(this), v2Router.WETH());\r\n//             // require(pair != address(0), \"Pair not found\");\r\n\r\n//             // console.log('inital pair address: %s, final pair: %s', lpTokenPairAddress, pair);\r\n\r\n            \r\n\r\n//             // uint newBalance =IERC20(lpTokenPairAddress).balanceOf(address(this));\r\n\r\n//             // console.log('liquidity: %d, newBalance: %d', liquidity, newBalance);\r\n\r\n//             // Transfer the LP tokens to the burn address\r\n//             require(IERC20(lpTokenPairAddress).transfer(BURN_ADDRESS, liquidity), \"Burn LP tokens failed\");\r\n//         }\r\n//     }\r\n\r\n\t\r\n\r\n// \tfunction withdraw(address payable _to, uint256 _amount) public onlyOwner {\r\n//         if(!liquiditySent){\r\n//             revert('LiqdtyUnsent');\r\n//         }\r\n//         require(_amount <= payable(address(this)).balance);\r\n//         safeTransferETH(_to, _amount);\r\n//     }\r\n\r\n// \tfunction safeTransferETH(address to, uint256 value) internal {\r\n//         (bool success, ) = to.call{ value: value }(new bytes(0));\r\n//         require(success, \"TransferHelper::safeTransferETH: ETH transfer failed\");\r\n//     }\r\n\r\n//     // Fallback function to receive ETH\r\n//     receive() external payable {}\r\n// }\r\n\r\n"
    },
    "contracts/V2/PopCoinFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.26;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"../IDexRouter.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\r\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\r\nimport { ERC20 as SolmateERC20 } from \"solmate/src/tokens/ERC20.sol\";\r\nimport {FunTokenV2} from \"./FunToken.sol\";\r\n\r\nerror NotPermitted();\r\nerror Paused();\r\nerror InsufficientPayment();\r\nerror InvalidAmountIn();\r\nerror InsufficientOutput();\r\nerror DeadlineExceeded();\r\nerror InvalidToken();\r\nerror FeeTooHigh();\r\nerror NotEnoughBalanceForFees();\r\nerror NotEnoughFee(uint feeToPay);\r\nerror NotEnoughBalance();\r\nerror TokenApprovalRequired();\r\nerror UnsupportedRouter();\r\nerror ExceededMaxGasPrice(uint maxGasPrice);\r\n\r\nstruct TokenCreateInfo {\r\n    string name;\r\n    string symbol;\r\n    string description;\r\n    string logo;\r\n    string banner;\r\n    string twitter;\r\n    string telegram;\r\n    string website;\r\n    address routerAddress;\r\n    uint initialCreatorBuy;\r\n}\r\nstruct Pool {\r\n    FunTokenV2 token;\r\n    uint256 tokenReserve;\r\n    uint256 virtualTokenReserve;\r\n    uint256 ethReserve;\r\n    uint256 virtualEthReserve;\r\n    uint256 lastPrice;\r\n    uint256 lastMcapInEth;\r\n    uint256 lastTimestamp;\r\n    uint256 lastBlock;\r\n    address creator;\r\n    address routerAddress;\r\n    bool migrated;\r\n}\r\n\r\ncontract PopCoinFactoryV2 is ReentrancyGuard, Ownable {\r\n    using FixedPointMathLib for uint256;\r\n    address public constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\r\n    uint256 public constant FEE_DENOMINATOR = 100_00;\r\n    \r\n    uint256 public constant INIT_VIRTUAL_TOKEN_RESERVE = 1073000000 ether;\r\n    uint256 public constant INIT_REAL_TOKEN_RESERVE = 793100000 ether;\r\n    uint256 public constant TOTAL_SUPPLY = 1_000_000_000 ether;\r\n\r\n    uint256 public initVirtualEthReserve;\r\n    uint256 public migrationThreshold;\r\n    uint256 public CURVE_CONSTANT;\r\n    uint256 public deployLiquidityFee=1.5 ether;\r\n    uint256 public tokenCreateFee=0.0005 ether;\r\n    uint256 public transactionFeePercent=100;\r\n    \r\n    \r\n    address payable public adminPaymentAddress;\r\n\r\n    mapping(address => bool) public routersSupported; \r\n\r\n    bool public paused;\r\n    mapping(address => Pool) public tokenPool;\r\n\r\n     mapping(address => address[]) public ownerTokens;\r\n\r\n    mapping(address => address) public tokenCreators; // token -> creator\r\n\r\n    event TokenCreated(\r\n        address indexed creator,\r\n        address indexed tokenAddress,\r\n        string name,\r\n        string symbol,\r\n        string description,\r\n        string logo,\r\n        string banner,\r\n        string twitter,\r\n        string telegram,\r\n        string website,\r\n        address routerAddress,\r\n        uint256 timestamp\r\n    );\r\n    event PriceUpdated(\r\n        address indexed token,\r\n        address indexed trader,\r\n        uint256 price,\r\n        uint256 mcapEth,\r\n        uint256 timestamp\r\n    );\r\n    event TokenTraded(\r\n        address indexed trader,\r\n        address indexed tokenAddress,\r\n        uint256 tokensTraded,\r\n        uint256 amountPaid,\r\n        uint256 fee,\r\n        uint256 timestamp,\r\n        bool isBuy\r\n    );\r\n    event LiquidityMigrated(\r\n        address indexed tokenAddress,\r\n        address indexed pair, \r\n        uint256 ethAmount, \r\n        uint256 tokenAmount, \r\n        uint256 fee, \r\n        uint256 timestamp\r\n    );\r\n\r\n\r\n    uint256 public maxGasPrice = 1 * 10**18; // Adjustable value\r\n    \r\n\r\n    modifier onlyValidGasPrice() {    \r\n        require(tx.gasprice <= maxGasPrice, ExceededMaxGasPrice(maxGasPrice));    \r\n        _;  \r\n    }\r\n\r\n    modifier onlyUnPaused() {\r\n        if (paused) revert Paused();\r\n        _;\r\n    }\r\n    modifier checkDeadline(uint256 deadline) {\r\n        if (block.timestamp > deadline) revert DeadlineExceeded();\r\n        _;\r\n    }\r\n\r\n\r\n    constructor(  \r\n        uint256 _initVirtualEthReserve,\r\n        uint256 _tokenCreateFee,\r\n        uint256 _deployLiquidityFee,        \r\n        uint _transactionFeePercent,\r\n        address[4] memory _dexRouterAddresses,\r\n        uint256 _maxGasPrice\r\n    ) Ownable(msg.sender) {\r\n        adminPaymentAddress = payable(msg.sender);\r\n        deployLiquidityFee=_deployLiquidityFee;\r\n        tokenCreateFee=_tokenCreateFee;\r\n        transactionFeePercent=_transactionFeePercent;\r\n        paused = false;\r\n        maxGasPrice=_maxGasPrice;\r\n\r\n        initVirtualEthReserve = _initVirtualEthReserve;\r\n        CURVE_CONSTANT = initVirtualEthReserve * INIT_VIRTUAL_TOKEN_RESERVE;\r\n        migrationThreshold = CURVE_CONSTANT / (INIT_VIRTUAL_TOKEN_RESERVE - INIT_REAL_TOKEN_RESERVE) - initVirtualEthReserve;\r\n\r\n        for(uint i=0; i< _dexRouterAddresses.length; i++){\r\n            if(_dexRouterAddresses[i]!= address(0)){\r\n                routersSupported[_dexRouterAddresses[i]]= true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setMaxGasPrice(uint256 _maxGasPrice) public onlyOwner {    \r\n        maxGasPrice=_maxGasPrice; \r\n        \r\n    }\r\n\r\n\r\n    function createToken(TokenCreateInfo memory tokenInfo) public payable onlyUnPaused returns (address) {\r\n        \r\n        if (msg.value < tokenCreateFee + tokenInfo.initialCreatorBuy) revert InsufficientPayment();\r\n        if (tokenCreateFee > 0) SafeTransferLib.safeTransferETH(adminPaymentAddress, tokenCreateFee);\r\n        FunTokenV2 token = new FunTokenV2(tokenInfo.name, tokenInfo.symbol, address(this), msg.sender, TOTAL_SUPPLY, tokenInfo.routerAddress);\r\n        Pool storage pool = tokenPool[address(token)];\r\n        pool.token = token;\r\n        pool.tokenReserve = INIT_REAL_TOKEN_RESERVE;\r\n        pool.virtualTokenReserve = INIT_VIRTUAL_TOKEN_RESERVE;\r\n        pool.ethReserve = 0;\r\n        pool.virtualEthReserve = initVirtualEthReserve;\r\n        pool.lastPrice = initVirtualEthReserve.divWadDown(INIT_VIRTUAL_TOKEN_RESERVE);\r\n        pool.lastMcapInEth = TOTAL_SUPPLY.mulWadUp(pool.lastPrice);\r\n        pool.lastTimestamp = block.timestamp;\r\n        pool.lastBlock = block.number;\r\n        pool.creator = msg.sender;\r\n        pool.routerAddress=tokenInfo.routerAddress;\r\n        pool.migrated = false;\r\n\r\n        ownerTokens[msg.sender].push(address(token));\r\n        tokenCreators[address(token)]=msg.sender; \r\n\r\n        emit TokenCreated(\r\n            msg.sender,\r\n            address(token),\r\n            tokenInfo.name,\r\n            tokenInfo.symbol,\r\n            tokenInfo.description,\r\n            tokenInfo.logo,\r\n            tokenInfo.banner,\r\n            tokenInfo.twitter,\r\n            tokenInfo.telegram,\r\n            tokenInfo.website,\r\n            tokenInfo.routerAddress,\r\n            block.timestamp\r\n        );\r\n        emit PriceUpdated(\r\n            address(token), \r\n            msg.sender, \r\n            pool.lastPrice, \r\n            pool.lastMcapInEth, \r\n            block.timestamp\r\n        );\r\n\r\n        if(tokenInfo.initialCreatorBuy>0){\r\n            \r\n            _swapEthForTokens(address(token),tokenInfo.initialCreatorBuy, 0, block.timestamp+1000, true);\r\n        }\r\n        return address(token);\r\n    }\r\n\r\n    function _swapEthForTokens(address token, uint256 amountIn, uint256 amountOutMin, uint256 deadline, bool suspendFee) \r\n        private \r\n        onlyUnPaused \r\n        checkDeadline(deadline) \r\n        returns (uint256 amountOut) \r\n    {\r\n        \r\n        if (amountIn == 0) revert InvalidAmountIn();\r\n        uint256 fee = 0;\r\n        \r\n        if (tokenPool[token].migrated) {\r\n            \r\n            ( amountOut, fee ) = _swapETHForTokenOnRouter(token, amountIn, amountOutMin, msg.sender);\r\n        } else {\r\n            \r\n            if(!suspendFee){\r\n                fee = amountIn * transactionFeePercent / FEE_DENOMINATOR;\r\n                amountIn -= fee;\r\n                SafeTransferLib.safeTransferETH(adminPaymentAddress, fee);\r\n            }\r\n            \r\n            \r\n            if (tokenPool[token].creator == address(0)) revert InvalidToken();\r\n            \r\n            // Add Fee to calcAmountOut Check, since it alway uses fee in calculation\r\n            (uint newVirtualEthReserve,uint newVirtualTokenReserve,uint amountOut1) = _calcAmountOutFromEth(token, amountIn+fee);\r\n            \r\n            amountOut=amountOut1;\r\n            if (amountOut < amountOutMin) revert InsufficientOutput();\r\n\r\n            tokenPool[token].virtualEthReserve = newVirtualEthReserve;\r\n            tokenPool[token].virtualTokenReserve = newVirtualTokenReserve;\r\n            tokenPool[token].lastPrice = newVirtualEthReserve.divWadDown(newVirtualTokenReserve);\r\n            tokenPool[token].lastMcapInEth = TOTAL_SUPPLY.mulWadUp(tokenPool[token].lastPrice);\r\n            tokenPool[token].lastTimestamp = block.timestamp;\r\n            tokenPool[token].lastBlock = block.number;\r\n            tokenPool[token].ethReserve += amountIn;            \r\n            tokenPool[token].tokenReserve -= amountOut;\r\n            \r\n            SafeTransferLib.safeTransfer(SolmateERC20(token), msg.sender, amountOut);\r\n            emit PriceUpdated(token, msg.sender, tokenPool[token].lastPrice, tokenPool[token].lastMcapInEth, block.timestamp);\r\n\r\n            if (tokenPool[token].ethReserve >= migrationThreshold) {\r\n                _migrateLiquidity(token);\r\n            }\r\n        }\r\n        emit TokenTraded(msg.sender, token, amountOut,amountIn, fee, block.timestamp, true);\r\n    }\r\n\r\n    function swapEthForTokens(address token, uint256 amountIn, uint256 amountOutMin, uint256 deadline) \r\n        public \r\n        payable \r\n        onlyValidGasPrice\r\n        nonReentrant \r\n        onlyUnPaused \r\n        checkDeadline(deadline) \r\n        \r\n        returns (uint256 amountOut) \r\n    {\r\n        \r\n        if (msg.value < amountIn) revert InsufficientPayment();\r\n        if (amountIn == 0) revert InvalidAmountIn();\r\n        return _swapEthForTokens(token, amountIn, amountOutMin, deadline, false);\r\n        \r\n        \r\n    }\r\n\r\n    function swapTokensForEth(address token, uint256 tokensIn, uint256 amountOutMin, uint256 deadline)\r\n        public\r\n        onlyValidGasPrice\r\n        nonReentrant\r\n        onlyUnPaused\r\n        checkDeadline(deadline)\r\n\r\n        returns (uint256 amountOut)\r\n    {\r\n        uint256 fee = 0;\r\n        if (tokensIn == 0) revert InvalidAmountIn();        \r\n        SafeTransferLib.safeTransferFrom(SolmateERC20(token), msg.sender, address(this), tokensIn);\r\n        if (tokenPool[token].migrated) {\r\n            ( amountOut, fee ) = _swapTokenForETHOnRouter(token, tokensIn, amountOutMin, msg.sender);\r\n        } else {\r\n            if (tokenPool[token].creator == address(0)) revert InvalidToken();\r\n\r\n            (uint newVirtualEthReserve,uint newVirtualTokenReserve,uint amountOut1)= _calcAmountOutFromToken(token, tokensIn );\r\n            amountOut=amountOut1;\r\n            tokenPool[token].virtualTokenReserve = newVirtualTokenReserve;\r\n            tokenPool[token].virtualEthReserve = newVirtualEthReserve;\r\n            tokenPool[token].lastPrice = newVirtualEthReserve.divWadDown(newVirtualTokenReserve);\r\n            tokenPool[token].lastMcapInEth = TOTAL_SUPPLY.mulWadUp(tokenPool[token].lastPrice);\r\n            tokenPool[token].lastTimestamp = block.timestamp;\r\n            tokenPool[token].lastBlock = block.number;\r\n            tokenPool[token].tokenReserve += tokensIn;\r\n            tokenPool[token].ethReserve -= amountOut;\r\n\r\n            fee = amountOut * transactionFeePercent / FEE_DENOMINATOR;\r\n            amountOut -= fee;\r\n            if (amountOut < amountOutMin-fee) revert InsufficientOutput();\r\n            SafeTransferLib.safeTransferETH(adminPaymentAddress, fee);\r\n            SafeTransferLib.safeTransferETH(msg.sender, amountOut);\r\n\r\n            emit PriceUpdated(token, msg.sender, tokenPool[token].lastPrice, tokenPool[token].lastMcapInEth, block.timestamp);\r\n        }\r\n        emit TokenTraded(msg.sender, token, tokensIn, amountOut, fee, block.timestamp, false);\r\n    }\r\n\r\n    function _migrateLiquidity(address tokenAddress) private {\r\n        if (tokenPool[tokenAddress].creator == address(0)) revert InvalidToken();\r\n        Pool storage poolToken = tokenPool[tokenAddress];\r\n        poolToken.lastTimestamp = block.timestamp;\r\n        poolToken.lastBlock = block.number;\r\n\r\n        uint256 fee = deployLiquidityFee;        \r\n        if(poolToken.ethReserve < fee) revert NotEnoughBalanceForFees();\r\n        SafeTransferLib.safeTransferETH(adminPaymentAddress, fee);\r\n        \r\n        uint256 ethAmount = poolToken.ethReserve - fee;\r\n        if(address(this).balance < ethAmount) revert NotEnoughBalance();\r\n\r\n        uint256 tokenAmount = TOTAL_SUPPLY - INIT_REAL_TOKEN_RESERVE;        \r\n\r\n        FunTokenV2(tokenAddress).setIsApprovable(true);\r\n        bool success = FunTokenV2(tokenAddress).approve(poolToken.routerAddress, tokenAmount);        \r\n        if(!success){\r\n            revert TokenApprovalRequired();\r\n        }\r\n        \r\n        IDexRouter router = IDexRouter(poolToken.routerAddress) ;\r\n        IDexFactory factory = IDexFactory(router.factory());\r\n        address lpTokenPairAddress = factory.getPair(tokenAddress, router.WETH());\r\n        \r\n        if (lpTokenPairAddress == address(0)) {\r\n            lpTokenPairAddress = factory.createPair(tokenAddress, router.WETH());\r\n        }\r\n\r\n        router.addLiquidityETH{ value: ethAmount }(\r\n            tokenAddress,\r\n            tokenAmount,\r\n            tokenAmount,\r\n            ethAmount,\r\n            BURN_ADDRESS, // permanently lock the liquidity\r\n            block.timestamp + 3 minutes\r\n        );\r\n        \r\n        poolToken.migrated = true;\r\n        poolToken.virtualEthReserve = 0;\r\n        poolToken.virtualTokenReserve = 0;\r\n        poolToken.ethReserve = 0;\r\n        poolToken.tokenReserve = 0;\r\n        emit LiquidityMigrated(tokenAddress, lpTokenPairAddress, ethAmount, tokenAmount, fee, block.timestamp);\r\n    }\r\n\r\n    function _calcAmountOutFromToken(address token, uint256 amountIn) private view returns (uint256 newVirtualEthReserve, uint256 newVirtualTokenReserve,uint256 amountOut) {\r\n        if (amountIn == 0) revert InvalidAmountIn();\r\n\r\n        newVirtualTokenReserve = tokenPool[token].virtualTokenReserve + amountIn;\r\n        newVirtualEthReserve = CURVE_CONSTANT / newVirtualTokenReserve;\r\n        amountOut = tokenPool[token].virtualEthReserve - newVirtualEthReserve;\r\n\r\n        uint256 fee = amountOut * transactionFeePercent / FEE_DENOMINATOR;\r\n        amountOut -= fee;\r\n    }\r\n\r\n    function calcAmountOutFromToken(address token, uint256 amountIn) public view returns (uint256 ) {\r\n        (,,uint amountOut) = _calcAmountOutFromToken(token, amountIn);\r\n        return amountOut;\r\n    }\r\n\r\n    function _calcAmountOutFromEth(address token, uint256 amountIn) private view returns (uint256 newVirtualEthReserve, uint256 newVirtualTokenReserve,uint256 amountOut) {\r\n        if (amountIn == 0) revert InvalidAmountIn();\r\n        \r\n        uint256 fee = amountIn * transactionFeePercent / FEE_DENOMINATOR;\r\n        \r\n        amountIn -= fee;\r\n\r\n        newVirtualEthReserve = tokenPool[token].virtualEthReserve + amountIn;\r\n        newVirtualTokenReserve = CURVE_CONSTANT / newVirtualEthReserve;\r\n        amountOut = tokenPool[token].virtualTokenReserve - newVirtualTokenReserve;\r\n\r\n        \r\n        if (amountOut > tokenPool[token].tokenReserve) {\r\n            amountOut = tokenPool[token].tokenReserve;\r\n        }\r\n    }\r\n\r\n    function calcAmountOutFromEth(address token, uint256 amountIn) public view returns (uint256 ) {\r\n        (,,uint amountOut) = _calcAmountOutFromEth(token, amountIn);\r\n        return amountOut;\r\n    }\r\n\r\n    function _swapETHForTokenOnRouter(address tokenAddress, uint256 amountIn, uint256 amountOutMin, address to) private returns (uint256, uint256) {\r\n        \r\n        if (msg.value < amountIn) revert InsufficientPayment();\r\n        uint256 fee = (amountIn * transactionFeePercent) / FEE_DENOMINATOR;\r\n        address[] memory path = new address[](2);\r\n        IDexRouter router = IDexRouter(tokenPool[tokenAddress].routerAddress) ;\r\n        path[0] = router.WETH();\r\n        path[1] = tokenAddress;\r\n        uint[] memory amounts = router.swapExactETHForTokens{value: amountIn - fee}(\r\n            amountOutMin,\r\n            path,\r\n            to,\r\n            block.timestamp + 1 minutes\r\n        );\r\n        uint amountOut = amounts[amounts.length - 1];\r\n        SafeTransferLib.safeTransferETH(adminPaymentAddress, fee);\r\n        return (amountOut, fee);\r\n    }\r\n\r\n    function _swapTokenForETHOnRouter(address tokenAddress, uint256 amountIn, uint256 amountOutMin, address to) private returns (uint256, uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = tokenAddress;\r\n\r\n        IDexRouter router = IDexRouter(tokenPool[tokenAddress].routerAddress) ;\r\n        path[1] = router.WETH();\r\n        FunTokenV2(tokenAddress).approve(address(router), amountIn);\r\n        uint[] memory amounts = router.swapExactTokensForETH(\r\n            amountIn, \r\n            amountOutMin, \r\n            path,\r\n            address(this), \r\n            block.timestamp + 1 minutes\r\n        );\r\n        uint amountOut = amounts[amounts.length - 1];\r\n        uint256 fee = (amountOut * transactionFeePercent) / FEE_DENOMINATOR;\r\n        SafeTransferLib.safeTransferETH(adminPaymentAddress, fee);\r\n        SafeTransferLib.safeTransferETH(to, amountOut - fee);\r\n        return (amountOut - fee, fee);\r\n    }\r\n\r\n    function changeInitVirtualEthReserve(uint256 value) external onlyOwner {\r\n        initVirtualEthReserve = value;\r\n        CURVE_CONSTANT = initVirtualEthReserve * INIT_VIRTUAL_TOKEN_RESERVE;\r\n        migrationThreshold = CURVE_CONSTANT / (INIT_VIRTUAL_TOKEN_RESERVE - INIT_REAL_TOKEN_RESERVE) - initVirtualEthReserve;\r\n    }\r\n\r\n    \r\n    function  changeAdminPaymentAddress(address newAdminPaymentAddress) public onlyOwner  {\r\n        \r\n        adminPaymentAddress = payable( newAdminPaymentAddress);\r\n    }\r\n\r\n    function changeCreationFee(uint256 value) external onlyOwner {\r\n        tokenCreateFee = value;\r\n    }\r\n    \r\n    function changeDeployLiquidityFee(uint256 value) public onlyOwner {\r\n        deployLiquidityFee = value;\r\n    }\r\n\r\n    function changeTransactionFeePercent(uint256 value) external onlyOwner {\r\n        transactionFeePercent = value;\r\n    }\r\n\r\n    \r\n\r\n    function setPaused(bool _val) external onlyOwner {\r\n        paused = _val;\r\n    }\r\n\r\n    function switchDexRouterSupport(address _dexRouterAddress, bool supported) public onlyOwner {\r\n        if(_dexRouterAddress!= address(0) && routersSupported[_dexRouterAddress] != supported){\r\n            routersSupported[_dexRouterAddress]= supported;\r\n        }\r\n    }\r\n\r\n    // function  getTokens(uint skip, uint take) public view returns(address[] memory) {\r\n    //     address[] memory list = new address[](take) ;\r\n    //     for (uint256 i=skip; i < skip + take ; i++) {\r\n    //         list[i-skip] = tokens[i]; \r\n    //     }\r\n    //     return list;\r\n    // }\r\n   \r\n    function  getOwnerTokensCount(address owner) public view returns(uint) {\r\n                return ownerTokens[owner].length;\r\n    }\r\n\r\n    function  getTokenCreator(address token) public view returns(address) {\r\n        \r\n        return tokenCreators[token];\r\n    }\r\n\r\n    function  getOwnerTokens(address owner,uint skip, uint take) public view returns(address[] memory) {\r\n        address[] memory list = new address[](take) ;\r\n        for (uint256 i=skip; i < skip + take ; i++) {\r\n            list[i-skip] = ownerTokens[owner][i]; \r\n        }\r\n        return list;\r\n    }\r\n\r\n    \r\n\r\n    function  withdrawFee(address to, uint amount) public onlyOwner  {\r\n        \r\n        uint balance = address(this).balance;\r\n        if(amount>=balance){\r\n            if(to==address(0)){\r\n                to=adminPaymentAddress;\r\n            }\r\n\r\n            payable(to).transfer(amount);\r\n        }else {\r\n            revert NotEnoughBalance();\r\n        }\r\n    }\r\n\r\n    \r\n    // function notifyTrade(address trader, address tokenAddress, uint tradeType, uint tokensTraded, uint amountPaid) public {\r\n    //     if(tokenAddress!= msg.sender || tokenCreators[tokenAddress]==address(0)){// token is not issued by Factory\r\n    //         revert('Token Not Issued by Factory');\r\n    //     }\r\n\r\n    //     emit TokenTraded(trader,tokenAddress,tradeType,tokensTraded,amountPaid);\r\n    // }\r\n\r\n\r\n    receive() external payable {}\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    },
    "solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    },
    "solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true
      }
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}